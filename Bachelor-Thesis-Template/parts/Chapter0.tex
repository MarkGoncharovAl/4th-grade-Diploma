\chapter{Введение}
\label{sec:Chapter0} \index{Chapter0}

В этой части надо описать предметную область, задачу из которой вы будете решать, объяснить её актуальность (почему надо что-то делать сейчас?).
Здесь же стоит ввести определения понятий, которые вам понадобятся в постановке задачи.


Статическая компиляция по-прежнему является основным автоматическим
способом повышения производительности программ на языках общего
назначения (С/С++). Интересно, что актуальность наличия
оптимизирующего статического компилятора не только не падает, но и
возрастает. 

Во-первых, появление новых процессорных архитектур влечет за
собой необходимость не только переноса на них существующих
промышленных компиляторов (GCC, LLVM), но
и разработки специфических
и настройки имеющихся оптимизаций (распределения регистров,
программной конвейеризации, использования особых возможностей набора
команд архитектуры). 

Во-вторых,
возникает необходимость использовать оптимизации с учетом профиля
программы без затрат на инструментирование, с помощью снятия профиля
программы через взятие проб (sampling) во время выполнения на нагрузках
промышленного типа. 

В-третьих, необходима поддержка новых стандартов
программирования для эффективного использования современных многоядерных
и гетерогенных архитектур (OpenMP, OpenCL, OpenACC,
Cilk+). Наконец, все вышеперечисленное имеет смысл делать лишь в
современных открытых компиляторных инфраструктурах типа GCC
и LLVM,
которые развиваются десятки лет
и уже содержат все необходимые базовые
машинно-зависимые
и машинно-независимые оптимизации, а также средства
для их создания. 

Так как указанные компиляторы являются многоплатформенными, возникают
естественные сложности при их использовании на различных архитектурах, таких как X86, ARM и набирающий популярность у нас в стране RISC-V. Особенности архитектур могут приводить
к тому, что машинно-независимые оптимизации,
в основном разработанные
и протестированные на устройствах Intel или IBM Power, будут выполняться неоптимально для других типов устройств. Однако именно развитие таких оптимизаций важно, потому что помогает развивать компиляторы для всех архитектур, что ценится Open Source сообществом.   

\section{Индуктивная переменная.}

Введём понятие \textbf{индуктивная переменной} -  переменная в циклах, последовательные значения которой образуют арифметическую прогрессию. Наиболее распространенный пример — счётчик цикла. Выделяют \textbf{базовые} (изменяемая на одну и ту же величину при итерации цикла) и \textbf{зависимые} (имеют более сложную математическую зависимость) индуктивные переменные. 

\begin{verbatim}
for (int i = 0; i < size; ++i) {
    int to_store = 200 + 9 * i;
    mas[i] = to_store;
}
\end{verbatim}

Мы должны выявить индукционные переменные, упростить вычисления, связанные с ними (так как переменная изменяется на каждой итерации цикла) и, по возможности, избавиться от большего числа. 



Можно заметить, что во многих архитектурах при обращении к адрессу может быть добавлен индекс 2, 4, 8 ... что не увеличивает длительности исполнения и может быть использано в машинно-зависимых оптимизациях. При работе с индукционными переменными мы не должны исключать возможность их работы.



\newpage