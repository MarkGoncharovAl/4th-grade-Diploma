*** IR Dump After Annotation2MetadataPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %retval = alloca ptr, align 8
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__pred.addr = alloca ptr, align 8
  %__trip_count = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %__first, ptr %__first.addr, align 8, !tbaa !6
  store ptr %__last, ptr %__last.addr, align 8, !tbaa !6
  store ptr %__pred, ptr %__pred.addr, align 8, !tbaa !6
  call void @llvm.lifetime.start.p0(i64 4, ptr %__trip_count) #2
  %0 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  %1 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  store i32 %conv, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %4 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %5 = load i32, ptr %4, align 4, !tbaa !10
  %call = call noundef signext i32 %3(i32 noundef signext %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %6, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  %7 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr = getelementptr inbounds i32, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %__first.addr, align 8, !tbaa !6
  %8 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %9 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %10 = load i32, ptr %9, align 4, !tbaa !10
  %call1 = call noundef signext i32 %8(i32 noundef signext %10)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %11 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %11, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %12 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr5 = getelementptr inbounds i32, ptr %12, i32 1
  store ptr %incdec.ptr5, ptr %__first.addr, align 8, !tbaa !6
  %13 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %14 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %15 = load i32, ptr %14, align 4, !tbaa !10
  %call6 = call noundef signext i32 %13(i32 noundef signext %15)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  %16 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %16, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %17 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr10 = getelementptr inbounds i32, ptr %17, i32 1
  store ptr %incdec.ptr10, ptr %__first.addr, align 8, !tbaa !6
  %18 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %19 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %20 = load i32, ptr %19, align 4, !tbaa !10
  %call11 = call noundef signext i32 %18(i32 noundef signext %20)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  %21 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %21, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %22 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr15 = getelementptr inbounds i32, ptr %22, i32 1
  store ptr %incdec.ptr15, ptr %__first.addr, align 8, !tbaa !6
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %23 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %dec = add nsw i32 %23, -1
  store i32 %dec, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  store ptr %24, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %__trip_count) #2
  %25 = load ptr, ptr %retval, align 8
  ret ptr %25
}

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }
attributes #1 = { argmemonly nocallback nofree nosync nounwind willreturn }
attributes #2 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"any pointer", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = !{!11, !11, i64 0}
!11 = !{!"int", !8, i64 0}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
*** IR Dump After ForceFunctionAttrsPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %retval = alloca ptr, align 8
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__pred.addr = alloca ptr, align 8
  %__trip_count = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %__first, ptr %__first.addr, align 8, !tbaa !6
  store ptr %__last, ptr %__last.addr, align 8, !tbaa !6
  store ptr %__pred, ptr %__pred.addr, align 8, !tbaa !6
  call void @llvm.lifetime.start.p0(i64 4, ptr %__trip_count) #2
  %0 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  %1 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  store i32 %conv, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %4 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %5 = load i32, ptr %4, align 4, !tbaa !10
  %call = call noundef signext i32 %3(i32 noundef signext %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %6, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  %7 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr = getelementptr inbounds i32, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %__first.addr, align 8, !tbaa !6
  %8 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %9 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %10 = load i32, ptr %9, align 4, !tbaa !10
  %call1 = call noundef signext i32 %8(i32 noundef signext %10)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %11 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %11, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %12 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr5 = getelementptr inbounds i32, ptr %12, i32 1
  store ptr %incdec.ptr5, ptr %__first.addr, align 8, !tbaa !6
  %13 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %14 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %15 = load i32, ptr %14, align 4, !tbaa !10
  %call6 = call noundef signext i32 %13(i32 noundef signext %15)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  %16 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %16, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %17 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr10 = getelementptr inbounds i32, ptr %17, i32 1
  store ptr %incdec.ptr10, ptr %__first.addr, align 8, !tbaa !6
  %18 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %19 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %20 = load i32, ptr %19, align 4, !tbaa !10
  %call11 = call noundef signext i32 %18(i32 noundef signext %20)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  %21 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %21, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %22 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr15 = getelementptr inbounds i32, ptr %22, i32 1
  store ptr %incdec.ptr15, ptr %__first.addr, align 8, !tbaa !6
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %23 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %dec = add nsw i32 %23, -1
  store i32 %dec, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  store ptr %24, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %__trip_count) #2
  %25 = load ptr, ptr %retval, align 8
  ret ptr %25
}

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }
attributes #1 = { argmemonly nocallback nofree nosync nounwind willreturn }
attributes #2 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"any pointer", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = !{!11, !11, i64 0}
!11 = !{!"int", !8, i64 0}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
*** IR Dump After InferFunctionAttrsPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %retval = alloca ptr, align 8
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__pred.addr = alloca ptr, align 8
  %__trip_count = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %__first, ptr %__first.addr, align 8, !tbaa !6
  store ptr %__last, ptr %__last.addr, align 8, !tbaa !6
  store ptr %__pred, ptr %__pred.addr, align 8, !tbaa !6
  call void @llvm.lifetime.start.p0(i64 4, ptr %__trip_count) #2
  %0 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  %1 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  store i32 %conv, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %4 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %5 = load i32, ptr %4, align 4, !tbaa !10
  %call = call noundef signext i32 %3(i32 noundef signext %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %6, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  %7 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr = getelementptr inbounds i32, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %__first.addr, align 8, !tbaa !6
  %8 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %9 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %10 = load i32, ptr %9, align 4, !tbaa !10
  %call1 = call noundef signext i32 %8(i32 noundef signext %10)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %11 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %11, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %12 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr5 = getelementptr inbounds i32, ptr %12, i32 1
  store ptr %incdec.ptr5, ptr %__first.addr, align 8, !tbaa !6
  %13 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %14 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %15 = load i32, ptr %14, align 4, !tbaa !10
  %call6 = call noundef signext i32 %13(i32 noundef signext %15)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  %16 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %16, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %17 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr10 = getelementptr inbounds i32, ptr %17, i32 1
  store ptr %incdec.ptr10, ptr %__first.addr, align 8, !tbaa !6
  %18 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %19 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %20 = load i32, ptr %19, align 4, !tbaa !10
  %call11 = call noundef signext i32 %18(i32 noundef signext %20)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  %21 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %21, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %22 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr15 = getelementptr inbounds i32, ptr %22, i32 1
  store ptr %incdec.ptr15, ptr %__first.addr, align 8, !tbaa !6
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %23 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %dec = add nsw i32 %23, -1
  store i32 %dec, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  store ptr %24, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %__trip_count) #2
  %25 = load ptr, ptr %retval, align 8
  ret ptr %25
}

; Function Attrs: argmemonly mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: argmemonly mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }
attributes #1 = { argmemonly mustprogress nocallback nofree nosync nounwind willreturn }
attributes #2 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"any pointer", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = !{!11, !11, i64 0}
!11 = !{!"int", !8, i64 0}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
*** IR Dump After CoroEarlyPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %retval = alloca ptr, align 8
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__pred.addr = alloca ptr, align 8
  %__trip_count = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %__first, ptr %__first.addr, align 8, !tbaa !6
  store ptr %__last, ptr %__last.addr, align 8, !tbaa !6
  store ptr %__pred, ptr %__pred.addr, align 8, !tbaa !6
  call void @llvm.lifetime.start.p0(i64 4, ptr %__trip_count) #2
  %0 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  %1 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  store i32 %conv, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %4 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %5 = load i32, ptr %4, align 4, !tbaa !10
  %call = call noundef signext i32 %3(i32 noundef signext %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %6, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  %7 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr = getelementptr inbounds i32, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %__first.addr, align 8, !tbaa !6
  %8 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %9 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %10 = load i32, ptr %9, align 4, !tbaa !10
  %call1 = call noundef signext i32 %8(i32 noundef signext %10)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %11 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %11, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %12 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr5 = getelementptr inbounds i32, ptr %12, i32 1
  store ptr %incdec.ptr5, ptr %__first.addr, align 8, !tbaa !6
  %13 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %14 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %15 = load i32, ptr %14, align 4, !tbaa !10
  %call6 = call noundef signext i32 %13(i32 noundef signext %15)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  %16 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %16, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %17 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr10 = getelementptr inbounds i32, ptr %17, i32 1
  store ptr %incdec.ptr10, ptr %__first.addr, align 8, !tbaa !6
  %18 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %19 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %20 = load i32, ptr %19, align 4, !tbaa !10
  %call11 = call noundef signext i32 %18(i32 noundef signext %20)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  %21 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %21, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %22 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr15 = getelementptr inbounds i32, ptr %22, i32 1
  store ptr %incdec.ptr15, ptr %__first.addr, align 8, !tbaa !6
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %23 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %dec = add nsw i32 %23, -1
  store i32 %dec, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  store ptr %24, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %__trip_count) #2
  %25 = load ptr, ptr %retval, align 8
  ret ptr %25
}

; Function Attrs: argmemonly mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: argmemonly mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }
attributes #1 = { argmemonly mustprogress nocallback nofree nosync nounwind willreturn }
attributes #2 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"any pointer", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = !{!11, !11, i64 0}
!11 = !{!"int", !8, i64 0}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
*** IR Dump After LowerExpectIntrinsicPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %retval = alloca ptr, align 8
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__pred.addr = alloca ptr, align 8
  %__trip_count = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %__first, ptr %__first.addr, align 8, !tbaa !6
  store ptr %__last, ptr %__last.addr, align 8, !tbaa !6
  store ptr %__pred, ptr %__pred.addr, align 8, !tbaa !6
  call void @llvm.lifetime.start.p0(i64 4, ptr %__trip_count) #2
  %0 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  %1 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  store i32 %conv, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %4 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %5 = load i32, ptr %4, align 4, !tbaa !10
  %call = call noundef signext i32 %3(i32 noundef signext %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %6, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  %7 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr = getelementptr inbounds i32, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %__first.addr, align 8, !tbaa !6
  %8 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %9 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %10 = load i32, ptr %9, align 4, !tbaa !10
  %call1 = call noundef signext i32 %8(i32 noundef signext %10)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %11 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %11, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %12 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr5 = getelementptr inbounds i32, ptr %12, i32 1
  store ptr %incdec.ptr5, ptr %__first.addr, align 8, !tbaa !6
  %13 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %14 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %15 = load i32, ptr %14, align 4, !tbaa !10
  %call6 = call noundef signext i32 %13(i32 noundef signext %15)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  %16 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %16, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %17 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr10 = getelementptr inbounds i32, ptr %17, i32 1
  store ptr %incdec.ptr10, ptr %__first.addr, align 8, !tbaa !6
  %18 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %19 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %20 = load i32, ptr %19, align 4, !tbaa !10
  %call11 = call noundef signext i32 %18(i32 noundef signext %20)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  %21 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %21, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %22 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr15 = getelementptr inbounds i32, ptr %22, i32 1
  store ptr %incdec.ptr15, ptr %__first.addr, align 8, !tbaa !6
  br label %for.inc

for.inc:                                          ; preds = %if.end14
  %23 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %dec = add nsw i32 %23, -1
  store i32 %dec, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  store ptr %24, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %__trip_count) #2
  %25 = load ptr, ptr %retval, align 8
  ret ptr %25
}
*** IR Dump After SimplifyCFGPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %retval = alloca ptr, align 8
  %__first.addr = alloca ptr, align 8
  %__last.addr = alloca ptr, align 8
  %__pred.addr = alloca ptr, align 8
  %__trip_count = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %__first, ptr %__first.addr, align 8, !tbaa !6
  store ptr %__last, ptr %__last.addr, align 8, !tbaa !6
  store ptr %__pred, ptr %__pred.addr, align 8, !tbaa !6
  call void @llvm.lifetime.start.p0(i64 4, ptr %__trip_count) #2
  %0 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  %1 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  store i32 %conv, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %2 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %4 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %5 = load i32, ptr %4, align 4, !tbaa !10
  %call = call noundef signext i32 %3(i32 noundef signext %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %6, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  %7 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr = getelementptr inbounds i32, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %__first.addr, align 8, !tbaa !6
  %8 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %9 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %10 = load i32, ptr %9, align 4, !tbaa !10
  %call1 = call noundef signext i32 %8(i32 noundef signext %10)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %11 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %11, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %12 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr5 = getelementptr inbounds i32, ptr %12, i32 1
  store ptr %incdec.ptr5, ptr %__first.addr, align 8, !tbaa !6
  %13 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %14 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %15 = load i32, ptr %14, align 4, !tbaa !10
  %call6 = call noundef signext i32 %13(i32 noundef signext %15)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  %16 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %16, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %17 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr10 = getelementptr inbounds i32, ptr %17, i32 1
  store ptr %incdec.ptr10, ptr %__first.addr, align 8, !tbaa !6
  %18 = load ptr, ptr %__pred.addr, align 8, !tbaa !6
  %19 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %20 = load i32, ptr %19, align 4, !tbaa !10
  %call11 = call noundef signext i32 %18(i32 noundef signext %20)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  %21 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  store ptr %21, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %22 = load ptr, ptr %__first.addr, align 8, !tbaa !6
  %incdec.ptr15 = getelementptr inbounds i32, ptr %22, i32 1
  store ptr %incdec.ptr15, ptr %__first.addr, align 8, !tbaa !6
  %23 = load i32, ptr %__trip_count, align 4, !tbaa !10
  %dec = add nsw i32 %23, -1
  store i32 %dec, ptr %__trip_count, align 4, !tbaa !10
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %__last.addr, align 8, !tbaa !6
  store ptr %24, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %__trip_count) #2
  %25 = load ptr, ptr %retval, align 8
  ret ptr %25
}
*** IR Dump After SROAPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i32 1
  %1 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %incdec.ptr, i32 1
  %2 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %incdec.ptr5, i32 1
  %3 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %incdec.ptr10, i32 1
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  %retval.0 = phi ptr [ %__first.addr.0, %if.then ], [ %incdec.ptr, %if.then3 ], [ %incdec.ptr5, %if.then8 ], [ %incdec.ptr10, %if.then13 ], [ %__last, %for.end ]
  ret ptr %retval.0
}
*** IR Dump After EarlyCSEPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i32 1
  %1 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %incdec.ptr, i32 1
  %2 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %incdec.ptr5, i32 1
  %3 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %incdec.ptr10, i32 1
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  %retval.0 = phi ptr [ %__first.addr.0, %if.then ], [ %incdec.ptr, %if.then3 ], [ %incdec.ptr5, %if.then8 ], [ %incdec.ptr10, %if.then13 ], [ %__last, %for.end ]
  ret ptr %retval.0
}
*** IR Dump After CallSiteSplittingPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i32 1
  %1 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %incdec.ptr, i32 1
  %2 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %incdec.ptr5, i32 1
  %3 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %incdec.ptr10, i32 1
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  %retval.0 = phi ptr [ %__first.addr.0, %if.then ], [ %incdec.ptr, %if.then3 ], [ %incdec.ptr5, %if.then8 ], [ %incdec.ptr10, %if.then13 ], [ %__last, %for.end ]
  ret ptr %retval.0
}
*** IR Dump After OpenMPOptPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i32 1
  %1 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %incdec.ptr, i32 1
  %2 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %incdec.ptr5, i32 1
  %3 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %incdec.ptr10, i32 1
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  %retval.0 = phi ptr [ %__first.addr.0, %if.then ], [ %incdec.ptr, %if.then3 ], [ %incdec.ptr5, %if.then8 ], [ %incdec.ptr10, %if.then13 ], [ %__last, %for.end ]
  ret ptr %retval.0
}

; Function Attrs: argmemonly mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: argmemonly mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }
attributes #1 = { argmemonly mustprogress nocallback nofree nosync nounwind willreturn }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After IPSCCPPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i32 1
  %1 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %incdec.ptr, i32 1
  %2 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %incdec.ptr5, i32 1
  %3 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %incdec.ptr10, i32 1
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  %retval.0 = phi ptr [ %__first.addr.0, %if.then ], [ %incdec.ptr, %if.then3 ], [ %incdec.ptr5, %if.then8 ], [ %incdec.ptr10, %if.then13 ], [ %__last, %for.end ]
  ret ptr %retval.0
}

; Function Attrs: argmemonly mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: argmemonly mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }
attributes #1 = { argmemonly mustprogress nocallback nofree nosync nounwind willreturn }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After CalledValuePropagationPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i32 1
  %1 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %incdec.ptr, i32 1
  %2 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %incdec.ptr5, i32 1
  %3 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %incdec.ptr10, i32 1
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  %retval.0 = phi ptr [ %__first.addr.0, %if.then ], [ %incdec.ptr, %if.then3 ], [ %incdec.ptr5, %if.then8 ], [ %incdec.ptr10, %if.then13 ], [ %__last, %for.end ]
  ret ptr %retval.0
}

; Function Attrs: argmemonly mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: argmemonly mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }
attributes #1 = { argmemonly mustprogress nocallback nofree nosync nounwind willreturn }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After GlobalOptPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i32 1
  %1 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %incdec.ptr, i32 1
  %2 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %incdec.ptr5, i32 1
  %3 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %incdec.ptr10, i32 1
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  %retval.0 = phi ptr [ %__first.addr.0, %if.then ], [ %incdec.ptr, %if.then3 ], [ %incdec.ptr5, %if.then8 ], [ %incdec.ptr10, %if.then13 ], [ %__last, %for.end ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After PromotePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %shr = ashr i64 %sub.ptr.div, 2
  %conv = trunc i64 %shr to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i32 1
  %1 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %incdec.ptr, i32 1
  %2 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %incdec.ptr5, i32 1
  %3 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %incdec.ptr10, i32 1
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  %retval.0 = phi ptr [ %__first.addr.0, %if.then ], [ %incdec.ptr, %if.then3 ], [ %incdec.ptr5, %if.then8 ], [ %incdec.ptr10, %if.then13 ], [ %__last, %for.end ]
  ret ptr %retval.0
}
*** IR Dump After InstCombinePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end4
  br label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end9
  br label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then13, %if.then8, %if.then3, %if.then
  %retval.0 = phi ptr [ %__first.addr.0, %if.then ], [ %incdec.ptr, %if.then3 ], [ %incdec.ptr5, %if.then8 ], [ %incdec.ptr10, %if.then13 ], [ %__last, %for.end ]
  ret ptr %retval.0
}
*** IR Dump After SimplifyCFGPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After RequireAnalysisPass<GlobalsAA, Module> on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After InvalidateAnalysisPass<AAManager> on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After RequireAnalysisPass<ProfileSummaryAnalysis, Module> on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After InlinerPass on (_Z3fooPiS_PFiiE) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After InlinerPass on (_Z3fooPiS_PFiiE) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr noundef %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After PostOrderFunctionAttrsPass on (_Z3fooPiS_PFiiE) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After ArgumentPromotionPass on (_Z3fooPiS_PFiiE) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After OpenMPOptCGSCCPass on (_Z3fooPiS_PFiiE) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After SROAPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After EarlyCSEPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After SpeculativeExecutionPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After JumpThreadingPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After CorrelatedValuePropagationPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After SimplifyCFGPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After InstCombinePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After AggressiveInstCombinePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After LibCallsShrinkWrapPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After TailCallElimPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After SimplifyCFGPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After ReassociatePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After RequireAnalysisPass<OptimizationRemarkEmitterAnalysis, Function> on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After LoopSimplifyPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After LCSSAPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
}
*** IR Dump After LoopInstSimplifyPass on for.cond ***

; Preheader:
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

; Loop:
for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

; Exit blocks
cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
*** IR Dump After LoopSimplifyCFGPass on for.cond ***

; Preheader:
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

; Loop:
for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

; Exit blocks
cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0

cleanup:                                          ; preds = %for.cond, %if.end9, %if.end4, %if.end, %for.body
  %retval.0 = phi ptr [ %__first.addr.0, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ], [ %__last, %for.cond ]
  ret ptr %retval.0
*** IR Dump After LICMPass on for.cond ***

; Preheader:
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  br label %for.cond

; Loop:
for.cond:                                         ; preds = %if.end14, %entry
  %__first.addr.0 = phi ptr [ %__first, %entry ], [ %incdec.ptr15, %if.end14 ]
  %__trip_count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.end14 ]
  %cmp = icmp sgt i32 %__trip_count.0, 0
  br i1 %cmp, label %for.body, label %cleanup.split.loop.exit

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %__first.addr.0, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.split.loop.exit39

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.0, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.0, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.0, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.0, i64 4
  %dec = add nsw i32 %__trip_count.0, -1
  br label %for.cond, !llvm.loop !10

; Exit blocks
cleanup.split.loop.exit:                          ; preds = %for.cond
  %retval.0.ph = phi ptr [ %__last, %for.cond ]
  br label %cleanup

cleanup.split.loop.exit39:                        ; preds = %for.body
  %retval.0.ph40 = phi ptr [ %__first.addr.0, %for.body ]
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.0.lcssa42 = phi ptr [ %__first.addr.0, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa42, i64 1
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.0.lcssa41 = phi ptr [ %__first.addr.0, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa41, i64 2
  br label %cleanup

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.0.lcssa = phi ptr [ %__first.addr.0, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa, i64 3
  br label %cleanup
*** IR Dump After LoopRotatePass on for.cond ***

; Preheader:
for.body.lr.ph:                                   ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.lr.ph, %if.end14
  %__trip_count.045 = phi i32 [ %conv, %for.body.lr.ph ], [ %dec, %if.end14 ]
  %__first.addr.044 = phi ptr [ %__first, %for.body.lr.ph ], [ %incdec.ptr15, %if.end14 ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.split.loop.exit39

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %dec, 0
  br i1 %cmp, label %for.body, label %for.cond.cleanup.split.loop.exit_crit_edge, !llvm.loop !10

; Exit blocks
cleanup.split.loop.exit39:                        ; preds = %for.body
  %retval.0.ph40 = phi ptr [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.0.lcssa42 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa42, i64 1
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.0.lcssa41 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa41, i64 2
  br label %cleanup

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.0.lcssa = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa, i64 3
  br label %cleanup

for.cond.cleanup.split.loop.exit_crit_edge:       ; preds = %if.end14
  %split = phi ptr [ %__last, %if.end14 ]
  br label %cleanup.split.loop.exit
*** IR Dump After LICMPass on for.body ***

; Preheader:
for.body.lr.ph:                                   ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.lr.ph, %if.end14
  %__trip_count.045 = phi i32 [ %conv, %for.body.lr.ph ], [ %dec, %if.end14 ]
  %__first.addr.044 = phi ptr [ %__first, %for.body.lr.ph ], [ %incdec.ptr15, %if.end14 ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.split.loop.exit39

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %dec, 0
  br i1 %cmp, label %for.body, label %for.cond.cleanup.split.loop.exit_crit_edge, !llvm.loop !10

; Exit blocks
cleanup.split.loop.exit39:                        ; preds = %for.body
  %retval.0.ph40 = phi ptr [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.0.lcssa42 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa42, i64 1
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.0.lcssa41 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa41, i64 2
  br label %cleanup

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.0.lcssa = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa, i64 3
  br label %cleanup

for.cond.cleanup.split.loop.exit_crit_edge:       ; preds = %if.end14
  %split = phi ptr [ %__last, %if.end14 ]
  br label %cleanup.split.loop.exit
*** IR Dump After SimpleLoopUnswitchPass on for.body ***

; Preheader:
for.body.lr.ph:                                   ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.lr.ph, %if.end14
  %__trip_count.045 = phi i32 [ %conv, %for.body.lr.ph ], [ %dec, %if.end14 ]
  %__first.addr.044 = phi ptr [ %__first, %for.body.lr.ph ], [ %incdec.ptr15, %if.end14 ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.split.loop.exit39

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %dec, 0
  br i1 %cmp, label %for.body, label %for.cond.cleanup.split.loop.exit_crit_edge, !llvm.loop !10

; Exit blocks
cleanup.split.loop.exit39:                        ; preds = %for.body
  %retval.0.ph40 = phi ptr [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.0.lcssa42 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa42, i64 1
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.0.lcssa41 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa41, i64 2
  br label %cleanup

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.0.lcssa = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa, i64 3
  br label %cleanup

for.cond.cleanup.split.loop.exit_crit_edge:       ; preds = %if.end14
  %split = phi ptr [ %__last, %if.end14 ]
  br label %cleanup.split.loop.exit
*** IR Dump After SimplifyCFGPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %dec, 0
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.0.lcssa = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa, i64 3
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.0.lcssa41 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa41, i64 2
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.0.lcssa42 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.0.lcssa42, i64 1
  br label %cleanup

cleanup:                                          ; preds = %for.body, %entry, %if.end14, %cleanup.split.loop.exit37, %cleanup.split.loop.exit35, %cleanup.split.loop.exit33
  %retval.0 = phi ptr [ %incdec.ptr10.le, %cleanup.split.loop.exit33 ], [ %incdec.ptr5.le, %cleanup.split.loop.exit35 ], [ %incdec.ptr.le, %cleanup.split.loop.exit37 ], [ %__last, %entry ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After InstCombinePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %for.body, %entry, %if.end14, %cleanup.split.loop.exit37, %cleanup.split.loop.exit35, %cleanup.split.loop.exit33
  %retval.0 = phi ptr [ %incdec.ptr10.le, %cleanup.split.loop.exit33 ], [ %incdec.ptr5.le, %cleanup.split.loop.exit35 ], [ %incdec.ptr.le, %cleanup.split.loop.exit37 ], [ %__last, %entry ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After LoopSimplifyPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %entry, %cleanup.split.loop.exit37, %cleanup.split.loop.exit35, %cleanup.split.loop.exit33
  %retval.0 = phi ptr [ %incdec.ptr10.le, %cleanup.split.loop.exit33 ], [ %incdec.ptr5.le, %cleanup.split.loop.exit35 ], [ %incdec.ptr.le, %cleanup.split.loop.exit37 ], [ %__last, %entry ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LCSSAPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.044.lcssa48 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa48, i64 3
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.044.lcssa47 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa47, i64 2
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.044.lcssa46 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa46, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %entry, %cleanup.split.loop.exit37, %cleanup.split.loop.exit35, %cleanup.split.loop.exit33
  %retval.0 = phi ptr [ %incdec.ptr10.le, %cleanup.split.loop.exit33 ], [ %incdec.ptr5.le, %cleanup.split.loop.exit35 ], [ %incdec.ptr.le, %cleanup.split.loop.exit37 ], [ %__last, %entry ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LoopIdiomRecognizePass on for.body ***

; Preheader:
for.body.preheader:                               ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

; Exit blocks
cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.044.lcssa46 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa46, i64 1
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.044.lcssa47 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa47, i64 2
  br label %cleanup

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.044.lcssa48 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa48, i64 3
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup
*** IR Dump After IndVarSimplifyPass on for.body ***

; Preheader:
for.body.preheader:                               ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

; Exit blocks
cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.044.lcssa46 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa46, i64 1
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.044.lcssa47 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa47, i64 2
  br label %cleanup

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.044.lcssa48 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa48, i64 3
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup
*** IR Dump After LoopDeletionPass on for.body ***

; Preheader:
for.body.preheader:                               ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

; Exit blocks
cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.044.lcssa46 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa46, i64 1
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.044.lcssa47 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa47, i64 2
  br label %cleanup

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.044.lcssa48 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa48, i64 3
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup
*** IR Dump After LoopFullUnrollPass on for.body ***

; Preheader:
for.body.preheader:                               ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

; Exit blocks
cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.044.lcssa46 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa46, i64 1
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.044.lcssa47 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa47, i64 2
  br label %cleanup

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.044.lcssa48 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa48, i64 3
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup
*** IR Dump After SROAPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.044.lcssa48 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa48, i64 3
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.044.lcssa47 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa47, i64 2
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.044.lcssa46 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa46, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %entry, %cleanup.split.loop.exit37, %cleanup.split.loop.exit35, %cleanup.split.loop.exit33
  %retval.0 = phi ptr [ %incdec.ptr10.le, %cleanup.split.loop.exit33 ], [ %incdec.ptr5.le, %cleanup.split.loop.exit35 ], [ %incdec.ptr.le, %cleanup.split.loop.exit37 ], [ %__last, %entry ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After MergedLoadStoreMotionPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.split.loop.exit33:                        ; preds = %if.end9
  %__first.addr.044.lcssa48 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa48, i64 3
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  %__first.addr.044.lcssa47 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa47, i64 2
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  %__first.addr.044.lcssa46 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa46, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %entry, %cleanup.split.loop.exit37, %cleanup.split.loop.exit35, %cleanup.split.loop.exit33
  %retval.0 = phi ptr [ %incdec.ptr10.le, %cleanup.split.loop.exit33 ], [ %incdec.ptr5.le, %cleanup.split.loop.exit35 ], [ %incdec.ptr.le, %cleanup.split.loop.exit37 ], [ %__last, %entry ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After GVNPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.split.loop.exit33:                        ; preds = %if.end9
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %entry, %cleanup.split.loop.exit37, %cleanup.split.loop.exit35, %cleanup.split.loop.exit33
  %retval.0 = phi ptr [ %incdec.ptr10, %cleanup.split.loop.exit33 ], [ %incdec.ptr5, %cleanup.split.loop.exit35 ], [ %incdec.ptr, %cleanup.split.loop.exit37 ], [ %__last, %entry ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After SCCPPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.split.loop.exit33:                        ; preds = %if.end9
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %entry, %cleanup.split.loop.exit37, %cleanup.split.loop.exit35, %cleanup.split.loop.exit33
  %retval.0 = phi ptr [ %incdec.ptr10, %cleanup.split.loop.exit33 ], [ %incdec.ptr5, %cleanup.split.loop.exit35 ], [ %incdec.ptr, %cleanup.split.loop.exit37 ], [ %__last, %entry ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After BDCEPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.split.loop.exit33:                        ; preds = %if.end9
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %entry, %cleanup.split.loop.exit37, %cleanup.split.loop.exit35, %cleanup.split.loop.exit33
  %retval.0 = phi ptr [ %incdec.ptr10, %cleanup.split.loop.exit33 ], [ %incdec.ptr5, %cleanup.split.loop.exit35 ], [ %incdec.ptr, %cleanup.split.loop.exit37 ], [ %__last, %entry ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After InstCombinePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.split.loop.exit37

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.split.loop.exit35

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.split.loop.exit33

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.split.loop.exit33:                        ; preds = %if.end9
  br label %cleanup

cleanup.split.loop.exit35:                        ; preds = %if.end4
  br label %cleanup

cleanup.split.loop.exit37:                        ; preds = %if.end
  br label %cleanup

cleanup.loopexit:                                 ; preds = %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %entry, %cleanup.split.loop.exit37, %cleanup.split.loop.exit35, %cleanup.split.loop.exit33
  %retval.0 = phi ptr [ %incdec.ptr10, %cleanup.split.loop.exit33 ], [ %incdec.ptr5, %cleanup.split.loop.exit35 ], [ %incdec.ptr, %cleanup.split.loop.exit37 ], [ %__last, %entry ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After JumpThreadingPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup:                                          ; preds = %for.body, %if.end14, %if.end, %if.end4, %if.end9, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10, %if.end9 ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr, %if.end ], [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After CorrelatedValuePropagationPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup:                                          ; preds = %for.body, %if.end14, %if.end, %if.end4, %if.end9, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10, %if.end9 ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr, %if.end ], [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After ADCEPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup:                                          ; preds = %for.body, %if.end14, %if.end, %if.end4, %if.end9, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10, %if.end9 ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr, %if.end ], [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After MemCpyOptPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup:                                          ; preds = %for.body, %if.end14, %if.end, %if.end4, %if.end9, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10, %if.end9 ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr, %if.end ], [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After DSEPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup:                                          ; preds = %for.body, %if.end14, %if.end, %if.end4, %if.end9, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10, %if.end9 ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr, %if.end ], [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After LoopSimplifyPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit:                                 ; preds = %if.end9, %if.end4, %if.end, %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LCSSAPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit:                                 ; preds = %if.end9, %if.end4, %if.end, %if.end14, %for.body
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ], [ %incdec.ptr, %if.end ], [ %incdec.ptr5, %if.end4 ], [ %incdec.ptr10, %if.end9 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LICMPass on for.body ***

; Preheader:
for.body.preheader:                               ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit.split.loop.exit55

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit.split.loop.exit53, !llvm.loop !10

; Exit blocks
cleanup.loopexit.split.loop.exit55:               ; preds = %for.body
  %retval.0.ph.ph56 = phi ptr [ %__first.addr.044, %for.body ]
  br label %cleanup.loopexit

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa58 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa58, i64 1
  br label %cleanup.loopexit

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa57 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa57, i64 2
  br label %cleanup.loopexit

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa, i64 3
  br label %cleanup.loopexit

cleanup.loopexit.split.loop.exit53:               ; preds = %if.end14
  %retval.0.ph.ph54 = phi ptr [ %__last, %if.end14 ]
  br label %cleanup.loopexit
*** IR Dump After CoroElidePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit.split.loop.exit55

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit.split.loop.exit53, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa, i64 3
  br label %cleanup.loopexit

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa57 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa57, i64 2
  br label %cleanup.loopexit

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa58 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa58, i64 1
  br label %cleanup.loopexit

cleanup.loopexit.split.loop.exit53:               ; preds = %if.end14
  %retval.0.ph.ph54 = phi ptr [ %__last, %if.end14 ]
  br label %cleanup.loopexit

cleanup.loopexit.split.loop.exit55:               ; preds = %for.body
  %retval.0.ph.ph56 = phi ptr [ %__first.addr.044, %for.body ]
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexit.split.loop.exit55, %cleanup.loopexit.split.loop.exit53, %cleanup.loopexit.split.loop.exit51, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit
  %retval.0.ph = phi ptr [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph.ph54, %cleanup.loopexit.split.loop.exit53 ], [ %retval.0.ph.ph56, %cleanup.loopexit.split.loop.exit55 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After SimplifyCFGPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa57 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa57, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa58 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa58, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After InstCombinePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After CoroSplitPass on (_Z3fooPiS_PFiiE) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After InvalidateAnalysisPass<ShouldNotRunFunctionPassesAnalysis> on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After DeadArgumentEliminationPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After CoroCleanupPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After GlobalOptPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After GlobalDCEPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After EliminateAvailableExternallyPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After ReversePostOrderFunctionAttrsPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After RecomputeGlobalsAAPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After Float2IntPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After LowerConstantIntrinsicsPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %if.end14, %for.body, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After LoopSimplifyPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LCSSAPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa61 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa61, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa60 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa60, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa59 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa59, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LoopRotatePass on for.body ***

; Preheader:
for.body.preheader:                               ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

; Exit blocks
cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa59 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa59, i64 1
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa60 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa60, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa61 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa61, i64 3
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup
*** IR Dump After LoopDeletionPass on for.body ***

; Preheader:
for.body.preheader:                               ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

; Exit blocks
cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa59 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa59, i64 1
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa60 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa60, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa61 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa61, i64 3
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup
*** IR Dump After LoopDistributePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa61 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa61, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa60 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa60, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa59 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa59, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After InjectTLIMappings on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa61 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa61, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa60 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa60, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa59 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa59, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LoopVectorizePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa61 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa61, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa60 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa60, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa59 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa59, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LoopLoadEliminationPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa61 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa61, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa60 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa60, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa59 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa59, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After InstCombinePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After SimplifyCFGPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After SLPVectorizerPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After VectorCombinePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After InstCombinePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After LoopUnrollPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa64 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa64, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa63 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa63, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa62 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa62, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After WarnMissedTransformationsPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa64 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa64, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa63 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa63, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa62 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa62, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After InstCombinePass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After RequireAnalysisPass<OptimizationRemarkEmitterAnalysis, Function> on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LoopSimplifyPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LCSSAPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa67 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa67, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa66 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa66, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa65 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa65, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LICMPass on for.body ***

; Preheader:
for.body.preheader:                               ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

; Exit blocks
cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa65 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa65, i64 1
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa66 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa66, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa67 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa67, i64 3
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup
*** IR Dump After AlignmentFromAssumptionsPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa67 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa67, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa66 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa66, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa65 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa65, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After LoopSinkPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %__first.addr.044.lcssa67 = phi ptr [ %__first.addr.044, %if.end9 ]
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa67, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %__first.addr.044.lcssa66 = phi ptr [ %__first.addr.044, %if.end4 ]
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa66, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %__first.addr.044.lcssa65 = phi ptr [ %__first.addr.044, %if.end ]
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044.lcssa65, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After InstSimplifyPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After DivRemPairsPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After TailCallElimPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After SimplifyCFGPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After GlobalDCEPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After ConstantMergePass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After CGProfilePass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After RelLookupTableConverterPass on [module] ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After AnnotationRemarksPass on _Z3fooPiS_PFiiE ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After ObjC ARC contraction (objc-arc-contract) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After Pre-ISel Intrinsic Lowering (pre-isel-intrinsic-lowering) ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After Expand large div/rem (expand-large-div-rem) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After Expand Atomic instructions (atomic-expand) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After RISCV gather/scatter lowering (riscv-gather-scatter-lowering) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After RISCV CodeGenPrepare (riscv-codegenprepare) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After Module Verifier (verify) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body, label %cleanup

for.body:                                         ; preds = %entry, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %entry ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %entry ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %for.body, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %__last, %if.end14 ], [ %__first.addr.044, %for.body ]
  ret ptr %retval.0
}
*** IR Dump After Canonicalize natural loops (loop-simplify) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %incdec.ptr10.le, %cleanup.loopexit.split.loop.exit ], [ %incdec.ptr5.le, %cleanup.loopexit.split.loop.exit49 ], [ %incdec.ptr.le, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Canonicalize Freeze Instructions in Loops (canon-freeze) ***
; Preheader:
for.body.preheader:                               ; preds = %entry
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.preheader, %if.end14
  %__trip_count.045 = phi i32 [ %dec, %if.end14 ], [ %conv, %for.body.preheader ]
  %__first.addr.044 = phi ptr [ %incdec.ptr15, %if.end14 ], [ %__first, %for.body.preheader ]
  %1 = load i32, ptr %__first.addr.044, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %1)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %cleanup.loopexit

if.end:                                           ; preds = %for.body
  %incdec.ptr = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  %2 = load i32, ptr %incdec.ptr, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %incdec.ptr5 = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  %3 = load i32, ptr %incdec.ptr5, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %incdec.ptr10 = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  %4 = load i32, ptr %incdec.ptr10, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %incdec.ptr15 = getelementptr inbounds i32, ptr %__first.addr.044, i64 4
  %dec = add nsw i32 %__trip_count.045, -1
  %cmp = icmp sgt i32 %__trip_count.045, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexit, !llvm.loop !10

; Exit blocks
cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %incdec.ptr.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 1
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  %incdec.ptr5.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 2
  br label %cleanup

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %incdec.ptr10.le = getelementptr inbounds i32, ptr %__first.addr.044, i64 3
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.body, %if.end14
  %retval.0.ph = phi ptr [ %__first.addr.044, %for.body ], [ %__last, %if.end14 ]
  br label %cleanup
*** IR Dump After Loop Strength Reduction (loop-reduce) ***
; Preheader:
for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

; Loop:
for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

; Exit blocks
for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit
*** IR Dump After Merge contiguous icmps into a memcmp (mergeicmps) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Expand memcmp() to load/stores (expandmemcmp) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Lower Garbage Collection Instructions (gc-lowering) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Shadow Stack GC Lowering (shadow-stack-gc-lowering) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Lower constant intrinsics (lower-constant-intrinsics) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Remove unreachable blocks from the CFG (unreachableblockelim) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Constant Hoisting (consthoist) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Replace intrinsics with calls to vector library (replace-with-veclib) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Partially inline calls to library functions (partially-inline-libcalls) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Expand vector predication intrinsics (expandvp) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Scalarize Masked Memory Intrinsics (scalarize-masked-mem-intrin) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After Expand reduction intrinsics (expand-reductions) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After TLS Variable Hoist (tlshoist) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = add i32 %conv, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %1, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %2 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %2)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %3 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %4 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup.loopexit.split.loop.exit49

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %5 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup.loopexitsplit, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit49:               ; preds = %if.end4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

cleanup.loopexitsplit:                            ; preds = %if.end14
  br label %cleanup.loopexit

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %cleanup.loopexitsplit, %for.body.cleanup.loopexit_crit_edge
  %retval.0.ph = phi ptr [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %cleanup.loopexitsplit ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit49, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %lsr.iv68, %cleanup.loopexit.split.loop.exit49 ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %retval.0.ph, %cleanup.loopexit ]
  ret ptr %retval.0
}
*** IR Dump After CodeGen Prepare (codegenprepare) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = trunc i64 %0 to i32
  %2 = add i32 %1, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %2, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %3 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %4 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %5 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %6 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %6)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup

cleanup:                                          ; preds = %for.body.cleanup.loopexit_crit_edge, %if.end14, %if.end4, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %lsr.iv68, %if.end4 ], [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After Exception handling preparation (dwarfehprepare) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = trunc i64 %0 to i32
  %2 = add i32 %1, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %2, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %3 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %4 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %5 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %6 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %6)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup

cleanup:                                          ; preds = %for.body.cleanup.loopexit_crit_edge, %if.end14, %if.end4, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %lsr.iv68, %if.end4 ], [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After A No-Op Barrier Pass (barrier) ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = trunc i64 %0 to i32
  %2 = add i32 %1, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %2, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %3 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %4 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %5 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %6 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %6)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup

cleanup:                                          ; preds = %for.body.cleanup.loopexit_crit_edge, %if.end14, %if.end4, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %lsr.iv68, %if.end4 ], [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
*** IR Dump After Safe Stack instrumentation pass (safe-stack) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = trunc i64 %0 to i32
  %2 = add i32 %1, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %2, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %3 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %4 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %5 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %6 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %6)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup

cleanup:                                          ; preds = %for.body.cleanup.loopexit_crit_edge, %if.end14, %if.end4, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %lsr.iv68, %if.end4 ], [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
*** IR Dump After Module Verifier (verify) ***
; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = trunc i64 %0 to i32
  %2 = add i32 %1, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %2, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %3 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %4 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %5 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %6 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %6)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup

cleanup:                                          ; preds = %for.body.cleanup.loopexit_crit_edge, %if.end14, %if.end4, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %lsr.iv68, %if.end4 ], [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}
# *** IR Dump After Finalize ISel and expand pseudo-instructions (finalize-isel) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  %25:gpr = ADDI $x0, 1
  BLT killed %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Early Tail Duplication (early-tailduplication) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  %25:gpr = ADDI $x0, 1
  BLT killed %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Optimize machine instruction PHIs (opt-phis) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  %25:gpr = ADDI $x0, 1
  BLT killed %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Slot index numbering (slotindexes) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
	  liveins: $x10, $x11, $x12
16B	  %13:gprjalr = COPY $x12
32B	  %12:gpr = COPY $x11
48B	  %11:gpr = COPY $x10
64B	  %14:gpr = SUB %12:gpr, %11:gpr
80B	  %0:gpr = SRLI killed %14:gpr, 4
96B	  %15:gpr = ADDIW %0:gpr, 0
112B	  %16:gpr = COPY $x0
128B	  BGE %16:gpr, killed %15:gpr, %bb.10
144B	  PseudoBR %bb.1

160B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

176B	  %1:gpr = ADDIW %0:gpr, 1
192B	  %2:gpr = ADDI %11:gpr, 8

208B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

224B	  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
240B	  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
256B	  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
272B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
288B	  $x10 = COPY %17:gpr
304B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
320B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
336B	  %18:gpr = COPY $x10
352B	  BNE %18:gpr, $x0, %bb.9
368B	  PseudoBR %bb.3

384B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

400B	  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
416B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
432B	  $x10 = COPY %19:gpr
448B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
464B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
480B	  %20:gpr = COPY $x10
496B	  BNE %20:gpr, $x0, %bb.8
512B	  PseudoBR %bb.4

528B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

544B	  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
560B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
576B	  $x10 = COPY %21:gpr
592B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
608B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
624B	  %22:gpr = COPY $x10
640B	  BNE %22:gpr, $x0, %bb.10
656B	  PseudoBR %bb.5

672B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

688B	  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
704B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
720B	  $x10 = COPY %23:gpr
736B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
752B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
768B	  %24:gpr = COPY $x10
784B	  BNE %24:gpr, $x0, %bb.7
800B	  PseudoBR %bb.6

816B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

832B	  %5:gpr = ADDIW %4:gpr, -1
848B	  %6:gpr = ADDI %3:gpr, 16
864B	  %25:gpr = ADDI $x0, 1
880B	  BLT killed %25:gpr, %5:gpr, %bb.2
896B	  PseudoBR %bb.10

912B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

928B	  %7:gpr = ADDI %3:gpr, 4
944B	  PseudoBR %bb.10

960B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

976B	  %8:gpr = ADDI %3:gpr, -4
992B	  PseudoBR %bb.10

1008B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1024B	  %9:gpr = ADDI %3:gpr, -8

1040B	bb.10.cleanup:
	; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

1056B	  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
1072B	  $x10 = COPY %10:gpr
1088B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Merge disjoint stack slots (stack-coloring) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  %25:gpr = ADDI $x0, 1
  BLT killed %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Local Stack Slot Allocation (localstackalloc) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  %25:gpr = ADDI $x0, 1
  BLT killed %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Remove dead machine instructions (dead-mi-elimination) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  %25:gpr = ADDI $x0, 1
  BLT killed %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Early Machine Loop Invariant Code Motion (early-machinelicm) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Machine Common Subexpression Elimination (machine-cse) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Machine code sinking (machine-sink) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Peephole Optimizations (peephole-opt) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Remove dead machine instructions (dead-mi-elimination) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Machine InstCombiner (machine-combiner) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After RISCV sext.w Removal (riscv-sextw-removal) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After RISCV Pre-RA pseudo instruction expansion pass (riscv-prera-expand-pseudo) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After RISCV Merge Base Offset (riscv-merge-base-offset) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After RISCV arith subtree rebalancing (riscv-arith-subtree-rebalancing) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After RISCV Insert VSETVLI pass (riscv-insert-vsetvli) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Detect Dead Lanes (detect-dead-lanes) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Process Implicit Definitions (processimpdefs) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Remove unreachable machine basic blocks (unreachable-mbb-elimination) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY $x12
  %12:gpr = COPY $x11
  %11:gpr = COPY $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW %0:gpr, 1
  %2:gpr = ADDI %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY $x10
  BNE %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY $x10
  BNE %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY $x10
  BNE %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY $x10
  BNE %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW %4:gpr, -1
  %6:gpr = ADDI %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY %10:gpr
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Live Variable Analysis (livevars) ***:
# Machine code for function _Z3fooPiS_PFiiE: IsSSA, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.10(0x30000000); %bb.1(62.50%), %bb.10(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY killed $x12
  %12:gpr = COPY killed $x11
  %11:gpr = COPY killed $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BGE killed %16:gpr, killed %15:gpr, %bb.10
  PseudoBR %bb.1

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW killed %0:gpr, 1
  %2:gpr = ADDI killed %11:gpr, 8
  %25:gpr = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %3:gpr = PHI %2:gpr, %bb.1, %6:gpr, %bb.6
  %4:gpr = PHI %1:gpr, %bb.1, %5:gpr, %bb.6
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY killed $x10
  BNE killed %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY killed $x10
  BNE killed %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.10(0x04000000); %bb.5(96.88%), %bb.10(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY killed $x10
  BNE killed %22:gpr, $x0, %bb.10
  PseudoBR %bb.5

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY killed $x10
  BNE killed %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.10(0x04000000); %bb.2(96.88%), %bb.10(3.12%)

  %5:gpr = ADDIW killed %4:gpr, -1
  %6:gpr = ADDI killed %3:gpr, 16
  BLT %25:gpr, %5:gpr, %bb.2
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI killed %3:gpr, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI killed %3:gpr, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI killed %3:gpr, -8

bb.10.cleanup:
; predecessors: %bb.0, %bb.9, %bb.8, %bb.4, %bb.7, %bb.6

  %10:gpr = PHI %12:gpr, %bb.0, %9:gpr, %bb.9, %8:gpr, %bb.8, %3:gpr, %bb.4, %7:gpr, %bb.7, %12:gpr, %bb.6
  $x10 = COPY killed %10:gpr
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Eliminate PHI nodes for register allocation (phi-node-elimination) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY killed $x12
  %12:gpr = COPY killed $x11
  %11:gpr = COPY killed $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BLT killed %16:gpr, killed %15:gpr, %bb.1

bb.11:
; predecessors: %bb.0
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %28:gpr = COPY killed %12:gpr
  PseudoBR %bb.10

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW killed %0:gpr, 1
  %2:gpr = ADDI killed %11:gpr, 8
  %25:gpr = ADDI $x0, 1
  %26:gpr = COPY killed %2:gpr
  %27:gpr = COPY killed %1:gpr

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %4:gpr = COPY killed %27:gpr
  %3:gpr = COPY killed %26:gpr
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY killed $x10
  BNE killed %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY killed $x10
  BNE killed %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY killed $x10
  BEQ killed %22:gpr, $x0, %bb.5

bb.12:
; predecessors: %bb.4
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %28:gpr = COPY killed %3:gpr
  PseudoBR %bb.10

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY killed $x10
  BNE killed %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

  %5:gpr = ADDIW killed %4:gpr, -1
  %6:gpr = ADDI killed %3:gpr, 16
  %26:gpr = COPY killed %6:gpr
  %27:gpr = COPY %5:gpr
  BLT %25:gpr, killed %5:gpr, %bb.2

bb.13:
; predecessors: %bb.6
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %28:gpr = COPY killed %12:gpr
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI killed %3:gpr, 4
  %28:gpr = COPY killed %7:gpr
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI killed %3:gpr, -4
  %28:gpr = COPY killed %8:gpr
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI killed %3:gpr, -8
  %28:gpr = COPY killed %9:gpr

bb.10.cleanup:
; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

  %10:gpr = COPY killed %28:gpr
  $x10 = COPY killed %10:gpr
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Two-Address instruction pass (twoaddressinstruction) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12
  %13:gprjalr = COPY killed $x12
  %12:gpr = COPY killed $x11
  %11:gpr = COPY killed $x10
  %14:gpr = SUB %12:gpr, %11:gpr
  %0:gpr = SRLI killed %14:gpr, 4
  %15:gpr = ADDIW %0:gpr, 0
  %16:gpr = COPY $x0
  BLT killed %16:gpr, killed %15:gpr, %bb.1

bb.11:
; predecessors: %bb.0
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %28:gpr = COPY killed %12:gpr
  PseudoBR %bb.10

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  %1:gpr = ADDIW killed %0:gpr, 1
  %2:gpr = ADDI killed %11:gpr, 8
  %25:gpr = ADDI $x0, 1
  %26:gpr = COPY killed %2:gpr
  %27:gpr = COPY killed %1:gpr

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

  %4:gpr = COPY killed %27:gpr
  %3:gpr = COPY killed %26:gpr
  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %17:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %18:gpr = COPY killed $x10
  BNE killed %18:gpr, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %19:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %20:gpr = COPY killed $x10
  BNE killed %20:gpr, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %21:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %22:gpr = COPY killed $x10
  BEQ killed %22:gpr, $x0, %bb.5

bb.12:
; predecessors: %bb.4
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %28:gpr = COPY killed %3:gpr
  PseudoBR %bb.10

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  $x10 = COPY killed %23:gpr
  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  %24:gpr = COPY killed $x10
  BNE killed %24:gpr, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

  %5:gpr = ADDIW killed %4:gpr, -1
  %6:gpr = ADDI killed %3:gpr, 16
  %26:gpr = COPY killed %6:gpr
  %27:gpr = COPY %5:gpr
  BLT %25:gpr, killed %5:gpr, %bb.2

bb.13:
; predecessors: %bb.6
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %28:gpr = COPY killed %12:gpr
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %7:gpr = ADDI killed %3:gpr, 4
  %28:gpr = COPY killed %7:gpr
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %8:gpr = ADDI killed %3:gpr, -4
  %28:gpr = COPY killed %8:gpr
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  %9:gpr = ADDI killed %3:gpr, -8
  %28:gpr = COPY killed %9:gpr

bb.10.cleanup:
; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

  %10:gpr = COPY killed %28:gpr
  $x10 = COPY killed %10:gpr
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Slot index numbering (slotindexes) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
16B	  %13:gprjalr = COPY killed $x12
32B	  %12:gpr = COPY killed $x11
48B	  %11:gpr = COPY killed $x10
64B	  %14:gpr = SUB %12:gpr, %11:gpr
80B	  %0:gpr = SRLI killed %14:gpr, 4
96B	  %15:gpr = ADDIW %0:gpr, 0
112B	  %16:gpr = COPY $x0
128B	  BLT killed %16:gpr, killed %15:gpr, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

160B	  %28:gpr = COPY killed %12:gpr
176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

208B	  %1:gpr = ADDIW killed %0:gpr, 1
224B	  %2:gpr = ADDI killed %11:gpr, 8
240B	  %25:gpr = ADDI $x0, 1
256B	  %26:gpr = COPY killed %2:gpr
272B	  %27:gpr = COPY killed %1:gpr

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

304B	  %4:gpr = COPY killed %27:gpr
320B	  %3:gpr = COPY killed %26:gpr
336B	  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
368B	  $x10 = COPY killed %17:gpr
384B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
416B	  %18:gpr = COPY killed $x10
432B	  BNE killed %18:gpr, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

480B	  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
512B	  $x10 = COPY killed %19:gpr
528B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
560B	  %20:gpr = COPY killed $x10
576B	  BNE killed %20:gpr, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

624B	  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
656B	  $x10 = COPY killed %21:gpr
672B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
704B	  %22:gpr = COPY killed $x10
720B	  BEQ killed %22:gpr, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

752B	  %28:gpr = COPY killed %3:gpr
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

800B	  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
832B	  $x10 = COPY killed %23:gpr
848B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
880B	  %24:gpr = COPY killed $x10
896B	  BNE killed %24:gpr, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

944B	  %5:gpr = ADDIW killed %4:gpr, -1
960B	  %6:gpr = ADDI killed %3:gpr, 16
976B	  %26:gpr = COPY killed %6:gpr
992B	  %27:gpr = COPY %5:gpr
1008B	  BLT %25:gpr, killed %5:gpr, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1040B	  %28:gpr = COPY killed %12:gpr
1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1088B	  %7:gpr = ADDI killed %3:gpr, 4
1104B	  %28:gpr = COPY killed %7:gpr
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1152B	  %8:gpr = ADDI killed %3:gpr, -4
1168B	  %28:gpr = COPY killed %8:gpr
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1216B	  %9:gpr = ADDI killed %3:gpr, -8
1232B	  %28:gpr = COPY killed %9:gpr

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

1264B	  %10:gpr = COPY killed %28:gpr
1280B	  $x10 = COPY killed %10:gpr
1296B	  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Live Interval Analysis (liveintervals) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
16B	  %13:gprjalr = COPY $x12
32B	  %12:gpr = COPY $x11
48B	  %11:gpr = COPY $x10
64B	  %14:gpr = SUB %12:gpr, %11:gpr
80B	  %0:gpr = SRLI %14:gpr, 4
96B	  %15:gpr = ADDIW %0:gpr, 0
112B	  %16:gpr = COPY $x0
128B	  BLT %16:gpr, %15:gpr, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

160B	  %28:gpr = COPY %12:gpr
176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

208B	  %1:gpr = ADDIW %0:gpr, 1
224B	  %2:gpr = ADDI %11:gpr, 8
240B	  %25:gpr = ADDI $x0, 1
256B	  %26:gpr = COPY %2:gpr
272B	  %27:gpr = COPY %1:gpr

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

304B	  %4:gpr = COPY %27:gpr
320B	  %3:gpr = COPY %26:gpr
336B	  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
368B	  $x10 = COPY %17:gpr
384B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
416B	  %18:gpr = COPY $x10
432B	  BNE %18:gpr, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

480B	  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
512B	  $x10 = COPY %19:gpr
528B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
560B	  %20:gpr = COPY $x10
576B	  BNE %20:gpr, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

624B	  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
656B	  $x10 = COPY %21:gpr
672B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
704B	  %22:gpr = COPY $x10
720B	  BEQ %22:gpr, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

752B	  %28:gpr = COPY %3:gpr
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

800B	  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
832B	  $x10 = COPY %23:gpr
848B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
880B	  %24:gpr = COPY $x10
896B	  BNE %24:gpr, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

944B	  %5:gpr = ADDIW %4:gpr, -1
960B	  %6:gpr = ADDI %3:gpr, 16
976B	  %26:gpr = COPY %6:gpr
992B	  %27:gpr = COPY %5:gpr
1008B	  BLT %25:gpr, %5:gpr, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1040B	  %28:gpr = COPY %12:gpr
1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1088B	  %7:gpr = ADDI %3:gpr, 4
1104B	  %28:gpr = COPY %7:gpr
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1152B	  %8:gpr = ADDI %3:gpr, -4
1168B	  %28:gpr = COPY %8:gpr
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1216B	  %9:gpr = ADDI %3:gpr, -8
1232B	  %28:gpr = COPY %9:gpr

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

1264B	  %10:gpr = COPY %28:gpr
1280B	  $x10 = COPY %10:gpr
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Simple Register Coalescing (simple-register-coalescing) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
16B	  %13:gprjalr = COPY $x12
32B	  %28:gpr = COPY $x11
48B	  %11:gpr = COPY $x10
64B	  %14:gpr = SUB %28:gpr, %11:gpr
80B	  %0:gpr = SRLI %14:gpr, 4
96B	  %15:gpr = ADDIW %0:gpr, 0
128B	  BLT $x0, %15:gpr, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

208B	  %27:gpr = ADDIW %0:gpr, 1
224B	  %3:gpr = ADDI %11:gpr, 8
240B	  %25:gpr = ADDI $x0, 1

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

336B	  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
368B	  $x10 = COPY %17:gpr
384B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
416B	  %18:gpr = COPY $x10
432B	  BNE %18:gpr, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

480B	  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
512B	  $x10 = COPY %19:gpr
528B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
560B	  %20:gpr = COPY $x10
576B	  BNE %20:gpr, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

624B	  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
656B	  $x10 = COPY %21:gpr
672B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
704B	  %22:gpr = COPY $x10
720B	  BEQ %22:gpr, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

752B	  %28:gpr = COPY %3:gpr
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

800B	  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
832B	  $x10 = COPY %23:gpr
848B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
880B	  %24:gpr = COPY $x10
896B	  BNE %24:gpr, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

944B	  %27:gpr = ADDIW %27:gpr, -1
960B	  %3:gpr = ADDI %3:gpr, 16
1008B	  BLT %25:gpr, %27:gpr, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1088B	  %28:gpr = ADDI %3:gpr, 4
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1152B	  %28:gpr = ADDI %3:gpr, -4
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1216B	  %28:gpr = ADDI %3:gpr, -8

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

1280B	  $x10 = COPY %28:gpr
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Rename Disconnected Subregister Components (rename-independent-subregs) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
16B	  %13:gprjalr = COPY $x12
32B	  %28:gpr = COPY $x11
48B	  %11:gpr = COPY $x10
64B	  %14:gpr = SUB %28:gpr, %11:gpr
80B	  %0:gpr = SRLI %14:gpr, 4
96B	  %15:gpr = ADDIW %0:gpr, 0
128B	  BLT $x0, %15:gpr, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

208B	  %27:gpr = ADDIW %0:gpr, 1
224B	  %3:gpr = ADDI %11:gpr, 8
240B	  %25:gpr = ADDI $x0, 1

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

336B	  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
368B	  $x10 = COPY %17:gpr
384B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
416B	  %18:gpr = COPY $x10
432B	  BNE %18:gpr, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

480B	  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
512B	  $x10 = COPY %19:gpr
528B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
560B	  %20:gpr = COPY $x10
576B	  BNE %20:gpr, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

624B	  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
656B	  $x10 = COPY %21:gpr
672B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
704B	  %22:gpr = COPY $x10
720B	  BEQ %22:gpr, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

752B	  %28:gpr = COPY %3:gpr
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

800B	  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
832B	  $x10 = COPY %23:gpr
848B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
880B	  %24:gpr = COPY $x10
896B	  BNE %24:gpr, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

944B	  %27:gpr = ADDIW %27:gpr, -1
960B	  %3:gpr = ADDI %3:gpr, 16
1008B	  BLT %25:gpr, %27:gpr, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1088B	  %28:gpr = ADDI %3:gpr, 4
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1152B	  %28:gpr = ADDI %3:gpr, -4
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1216B	  %28:gpr = ADDI %3:gpr, -8

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

1280B	  $x10 = COPY %28:gpr
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Machine Instruction Scheduler (machine-scheduler) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, TiedOpsRewritten
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
32B	  %28:gpr = COPY $x11
48B	  %11:gpr = COPY $x10
64B	  %14:gpr = SUB %28:gpr, %11:gpr
80B	  %0:gpr = SRLI %14:gpr, 4
96B	  %15:gpr = ADDIW %0:gpr, 0
104B	  %13:gprjalr = COPY $x12
128B	  BLT $x0, %15:gpr, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

208B	  %27:gpr = ADDIW %0:gpr, 1
224B	  %3:gpr = ADDI %11:gpr, 8
240B	  %25:gpr = ADDI $x0, 1

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

336B	  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
368B	  $x10 = COPY %17:gpr
384B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
416B	  %18:gpr = COPY $x10
432B	  BNE %18:gpr, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

480B	  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
512B	  $x10 = COPY %19:gpr
528B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
560B	  %20:gpr = COPY $x10
576B	  BNE %20:gpr, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

624B	  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
656B	  $x10 = COPY %21:gpr
672B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
704B	  %22:gpr = COPY $x10
720B	  BEQ %22:gpr, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

752B	  %28:gpr = COPY %3:gpr
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

800B	  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
832B	  $x10 = COPY %23:gpr
848B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
880B	  %24:gpr = COPY $x10
896B	  BNE %24:gpr, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

944B	  %27:gpr = ADDIW %27:gpr, -1
960B	  %3:gpr = ADDI %3:gpr, 16
1008B	  BLT %25:gpr, %27:gpr, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1088B	  %28:gpr = ADDI %3:gpr, 4
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1152B	  %28:gpr = ADDI %3:gpr, -4
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1216B	  %28:gpr = ADDI %3:gpr, -8

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

1280B	  $x10 = COPY %28:gpr
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Debug Variable Analysis (livedebugvars) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
32B	  %28:gpr = COPY $x11
48B	  %11:gpr = COPY $x10
64B	  %14:gpr = SUB %28:gpr, %11:gpr
80B	  %0:gpr = SRLI %14:gpr, 4
96B	  %15:gpr = ADDIW %0:gpr, 0
104B	  %13:gprjalr = COPY $x12
128B	  BLT $x0, %15:gpr, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

208B	  %27:gpr = ADDIW %0:gpr, 1
224B	  %3:gpr = ADDI %11:gpr, 8
240B	  %25:gpr = ADDI $x0, 1

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

336B	  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
368B	  $x10 = COPY %17:gpr
384B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
416B	  %18:gpr = COPY $x10
432B	  BNE %18:gpr, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

480B	  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
512B	  $x10 = COPY %19:gpr
528B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
560B	  %20:gpr = COPY $x10
576B	  BNE %20:gpr, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

624B	  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
656B	  $x10 = COPY %21:gpr
672B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
704B	  %22:gpr = COPY $x10
720B	  BEQ %22:gpr, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

752B	  %28:gpr = COPY %3:gpr
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

800B	  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
832B	  $x10 = COPY %23:gpr
848B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
880B	  %24:gpr = COPY $x10
896B	  BNE %24:gpr, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

944B	  %27:gpr = ADDIW %27:gpr, -1
960B	  %3:gpr = ADDI %3:gpr, 16
1008B	  BLT %25:gpr, %27:gpr, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1088B	  %28:gpr = ADDI %3:gpr, 4
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1152B	  %28:gpr = ADDI %3:gpr, -4
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1216B	  %28:gpr = ADDI %3:gpr, -8

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

1280B	  $x10 = COPY %28:gpr
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Live Stack Slot Analysis (livestacks) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
32B	  %28:gpr = COPY $x11
48B	  %11:gpr = COPY $x10
64B	  %14:gpr = SUB %28:gpr, %11:gpr
80B	  %0:gpr = SRLI %14:gpr, 4
96B	  %15:gpr = ADDIW %0:gpr, 0
104B	  %13:gprjalr = COPY $x12
128B	  BLT $x0, %15:gpr, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

208B	  %27:gpr = ADDIW %0:gpr, 1
224B	  %3:gpr = ADDI %11:gpr, 8
240B	  %25:gpr = ADDI $x0, 1

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

336B	  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
368B	  $x10 = COPY %17:gpr
384B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
416B	  %18:gpr = COPY $x10
432B	  BNE %18:gpr, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

480B	  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
512B	  $x10 = COPY %19:gpr
528B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
560B	  %20:gpr = COPY $x10
576B	  BNE %20:gpr, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

624B	  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
656B	  $x10 = COPY %21:gpr
672B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
704B	  %22:gpr = COPY $x10
720B	  BEQ %22:gpr, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

752B	  %28:gpr = COPY %3:gpr
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

800B	  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
832B	  $x10 = COPY %23:gpr
848B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
880B	  %24:gpr = COPY $x10
896B	  BNE %24:gpr, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

944B	  %27:gpr = ADDIW %27:gpr, -1
960B	  %3:gpr = ADDI %3:gpr, 16
1008B	  BLT %25:gpr, %27:gpr, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1088B	  %28:gpr = ADDI %3:gpr, 4
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1152B	  %28:gpr = ADDI %3:gpr, -4
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1216B	  %28:gpr = ADDI %3:gpr, -8

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

1280B	  $x10 = COPY %28:gpr
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Virtual Register Map (virtregmap) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
32B	  %28:gpr = COPY $x11
48B	  %11:gpr = COPY $x10
64B	  %14:gpr = SUB %28:gpr, %11:gpr
80B	  %0:gpr = SRLI %14:gpr, 4
96B	  %15:gpr = ADDIW %0:gpr, 0
104B	  %13:gprjalr = COPY $x12
128B	  BLT $x0, %15:gpr, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

208B	  %27:gpr = ADDIW %0:gpr, 1
224B	  %3:gpr = ADDI %11:gpr, 8
240B	  %25:gpr = ADDI $x0, 1

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

336B	  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
368B	  $x10 = COPY %17:gpr
384B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
416B	  %18:gpr = COPY $x10
432B	  BNE %18:gpr, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

480B	  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
512B	  $x10 = COPY %19:gpr
528B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
560B	  %20:gpr = COPY $x10
576B	  BNE %20:gpr, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

624B	  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
656B	  $x10 = COPY %21:gpr
672B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
704B	  %22:gpr = COPY $x10
720B	  BEQ %22:gpr, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

752B	  %28:gpr = COPY %3:gpr
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

800B	  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
832B	  $x10 = COPY %23:gpr
848B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
880B	  %24:gpr = COPY $x10
896B	  BNE %24:gpr, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

944B	  %27:gpr = ADDIW %27:gpr, -1
960B	  %3:gpr = ADDI %3:gpr, 16
1008B	  BLT %25:gpr, %27:gpr, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1088B	  %28:gpr = ADDI %3:gpr, 4
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1152B	  %28:gpr = ADDI %3:gpr, -4
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1216B	  %28:gpr = ADDI %3:gpr, -8

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

1280B	  $x10 = COPY %28:gpr
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Live Register Matrix (liveregmatrix) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
32B	  %28:gpr = COPY $x11
48B	  %11:gpr = COPY $x10
64B	  %14:gpr = SUB %28:gpr, %11:gpr
80B	  %0:gpr = SRLI %14:gpr, 4
96B	  %15:gpr = ADDIW %0:gpr, 0
104B	  %13:gprjalr = COPY $x12
128B	  BLT $x0, %15:gpr, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

208B	  %27:gpr = ADDIW %0:gpr, 1
224B	  %3:gpr = ADDI %11:gpr, 8
240B	  %25:gpr = ADDI $x0, 1

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

336B	  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
368B	  $x10 = COPY %17:gpr
384B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
416B	  %18:gpr = COPY $x10
432B	  BNE %18:gpr, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

480B	  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
512B	  $x10 = COPY %19:gpr
528B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
560B	  %20:gpr = COPY $x10
576B	  BNE %20:gpr, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

624B	  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
656B	  $x10 = COPY %21:gpr
672B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
704B	  %22:gpr = COPY $x10
720B	  BEQ %22:gpr, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

752B	  %28:gpr = COPY %3:gpr
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

800B	  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
832B	  $x10 = COPY %23:gpr
848B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
880B	  %24:gpr = COPY $x10
896B	  BNE %24:gpr, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

944B	  %27:gpr = ADDIW %27:gpr, -1
960B	  %3:gpr = ADDI %3:gpr, 16
1008B	  BLT %25:gpr, %27:gpr, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1088B	  %28:gpr = ADDI %3:gpr, 4
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1152B	  %28:gpr = ADDI %3:gpr, -4
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1216B	  %28:gpr = ADDI %3:gpr, -8

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

1280B	  $x10 = COPY %28:gpr
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Greedy Register Allocator (greedy) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10 in %11, $x11 in %12, $x12 in %13

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
32B	  %28:gpr = COPY $x11
48B	  %11:gpr = COPY $x10
64B	  %14:gpr = SUB %28:gpr, %11:gpr
80B	  %0:gpr = SRLI %14:gpr, 4
96B	  %15:gpr = ADDIW %0:gpr, 0
104B	  %13:gprjalr = COPY $x12
128B	  BLT $x0, %15:gpr, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)

208B	  %27:gpr = ADDIW %0:gpr, 1
224B	  %3:gpr = ADDI %11:gpr, 8
240B	  %25:gpr = ADDI $x0, 1

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)

336B	  %17:gpr = LW %3:gpr, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
368B	  $x10 = COPY %17:gpr
384B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
416B	  %18:gpr = COPY $x10
432B	  BNE %18:gpr, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)

480B	  %19:gpr = LW %3:gpr, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
512B	  $x10 = COPY %19:gpr
528B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
560B	  %20:gpr = COPY $x10
576B	  BNE %20:gpr, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)

624B	  %21:gpr = LW %3:gpr, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
656B	  $x10 = COPY %21:gpr
672B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
704B	  %22:gpr = COPY $x10
720B	  BEQ %22:gpr, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

752B	  %28:gpr = COPY %3:gpr
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)

800B	  %23:gpr = LW %3:gpr, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
832B	  $x10 = COPY %23:gpr
848B	  PseudoCALLIndirect %13:gprjalr, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
880B	  %24:gpr = COPY $x10
896B	  BNE %24:gpr, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)

944B	  %27:gpr = ADDIW %27:gpr, -1
960B	  %3:gpr = ADDI %3:gpr, 16
1008B	  BLT %25:gpr, %27:gpr, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1088B	  %28:gpr = ADDI %3:gpr, 4
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1152B	  %28:gpr = ADDI %3:gpr, -4
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)

1216B	  %28:gpr = ADDI %3:gpr, -8

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13

1280B	  $x10 = COPY %28:gpr
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Virtual Register Rewriter (virtregrewriter) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10, $x11, $x12

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
32B	  renamable $x18 = COPY $x11
64B	  renamable $x11 = SUB renamable $x18, renamable $x10
80B	  renamable $x11 = SRLI killed renamable $x11, 4
96B	  renamable $x13 = ADDIW renamable $x11, 0
104B	  renamable $x19 = COPY $x12
128B	  BLT $x0, killed renamable $x13, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x18
176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)
	  liveins: $x10, $x11, $x18, $x19
208B	  renamable $x9 = ADDIW killed renamable $x11, 1
224B	  renamable $x8 = ADDI killed renamable $x10, 8
240B	  renamable $x20 = ADDI $x0, 1

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
336B	  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
384B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
432B	  BNE killed renamable $x10, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
480B	  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
528B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
576B	  BNE killed renamable $x10, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
624B	  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
672B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
720B	  BEQ killed renamable $x10, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
752B	  renamable $x18 = COPY killed renamable $x8
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
800B	  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
848B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
896B	  BNE killed renamable $x10, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
944B	  renamable $x9 = ADDIW killed renamable $x9, -1
960B	  renamable $x8 = ADDI killed renamable $x8, 16
1008B	  BLT renamable $x20, renamable $x9, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x18
1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
1088B	  renamable $x18 = ADDI killed renamable $x8, 4
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
1152B	  renamable $x18 = ADDI killed renamable $x8, -4
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
1216B	  renamable $x18 = ADDI killed renamable $x8, -8

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13
	  liveins: $x18
1280B	  $x10 = COPY killed renamable $x18
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Register Allocation Pass Scoring (regallocscoringpass) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10, $x11, $x12

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
32B	  renamable $x18 = COPY $x11
64B	  renamable $x11 = SUB renamable $x18, renamable $x10
80B	  renamable $x11 = SRLI killed renamable $x11, 4
96B	  renamable $x13 = ADDIW renamable $x11, 0
104B	  renamable $x19 = COPY $x12
128B	  BLT $x0, killed renamable $x13, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x18
176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)
	  liveins: $x10, $x11, $x18, $x19
208B	  renamable $x9 = ADDIW killed renamable $x11, 1
224B	  renamable $x8 = ADDI killed renamable $x10, 8
240B	  renamable $x20 = ADDI $x0, 1

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
336B	  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
384B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
432B	  BNE killed renamable $x10, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
480B	  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
528B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
576B	  BNE killed renamable $x10, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
624B	  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
672B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
720B	  BEQ killed renamable $x10, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
752B	  renamable $x18 = COPY killed renamable $x8
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
800B	  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
848B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
896B	  BNE killed renamable $x10, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
944B	  renamable $x9 = ADDIW killed renamable $x9, -1
960B	  renamable $x8 = ADDI killed renamable $x8, 16
1008B	  BLT renamable $x20, renamable $x9, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x18
1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
1088B	  renamable $x18 = ADDI killed renamable $x8, 4
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
1152B	  renamable $x18 = ADDI killed renamable $x8, -4
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
1216B	  renamable $x18 = ADDI killed renamable $x8, -8

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13
	  liveins: $x18
1280B	  $x10 = COPY killed renamable $x18
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Stack Slot Coloring (stack-slot-coloring) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10, $x11, $x12

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
	  liveins: $x10, $x11, $x12
32B	  renamable $x18 = COPY $x11
64B	  renamable $x11 = SUB renamable $x18, renamable $x10
80B	  renamable $x11 = SRLI killed renamable $x11, 4
96B	  renamable $x13 = ADDIW renamable $x11, 0
104B	  renamable $x19 = COPY $x12
128B	  BLT $x0, killed renamable $x13, %bb.1

144B	bb.11:
	; predecessors: %bb.0
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x18
176B	  PseudoBR %bb.10

192B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(100.00%)
	  liveins: $x10, $x11, $x18, $x19
208B	  renamable $x9 = ADDIW killed renamable $x11, 1
224B	  renamable $x8 = ADDI killed renamable $x10, 8
240B	  renamable $x20 = ADDI $x0, 1

288B	bb.2.for.body:
	; predecessors: %bb.1, %bb.6
	  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
336B	  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
352B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
384B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
400B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
432B	  BNE killed renamable $x10, $x0, %bb.9
448B	  PseudoBR %bb.3

464B	bb.3.if.end:
	; predecessors: %bb.2
	  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
480B	  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
496B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
528B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
544B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
576B	  BNE killed renamable $x10, $x0, %bb.8
592B	  PseudoBR %bb.4

608B	bb.4.if.end4:
	; predecessors: %bb.3
	  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
624B	  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
640B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
672B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
688B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
720B	  BEQ killed renamable $x10, $x0, %bb.5

736B	bb.12:
	; predecessors: %bb.4
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
752B	  renamable $x18 = COPY killed renamable $x8
768B	  PseudoBR %bb.10

784B	bb.5.if.end9:
	; predecessors: %bb.4
	  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
800B	  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
816B	  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
848B	  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
864B	  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
896B	  BNE killed renamable $x10, $x0, %bb.7
912B	  PseudoBR %bb.6

928B	bb.6.if.end14:
	; predecessors: %bb.5
	  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)
	  liveins: $x8, $x9, $x18, $x19, $x20
944B	  renamable $x9 = ADDIW killed renamable $x9, -1
960B	  renamable $x8 = ADDI killed renamable $x8, 16
1008B	  BLT renamable $x20, renamable $x9, %bb.2

1024B	bb.13:
	; predecessors: %bb.6
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x18
1056B	  PseudoBR %bb.10

1072B	bb.7.cleanup.loopexit.split.loop.exit:
	; predecessors: %bb.5
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
1088B	  renamable $x18 = ADDI killed renamable $x8, 4
1120B	  PseudoBR %bb.10

1136B	bb.8.cleanup.loopexit.split.loop.exit51:
	; predecessors: %bb.3
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
1152B	  renamable $x18 = ADDI killed renamable $x8, -4
1184B	  PseudoBR %bb.10

1200B	bb.9.for.body.cleanup.loopexit_crit_edge:
	; predecessors: %bb.2
	  successors: %bb.10(0x80000000); %bb.10(100.00%)
	  liveins: $x8
1216B	  renamable $x18 = ADDI killed renamable $x8, -8

1248B	bb.10.cleanup:
	; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13
	  liveins: $x18
1280B	  $x10 = COPY killed renamable $x18
1296B	  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Machine Copy Propagation Pass (machine-cp) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12
  renamable $x18 = COPY $x11
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  renamable $x19 = COPY $x12
  BLT $x0, killed renamable $x13, %bb.1

bb.11:
; predecessors: %bb.0
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x18, $x19
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BEQ killed renamable $x10, $x0, %bb.5

bb.12:
; predecessors: %bb.4
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = COPY killed renamable $x8
  PseudoBR %bb.10

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2

bb.13:
; predecessors: %bb.6
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.10.cleanup:
; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13
  liveins: $x18
  $x10 = COPY killed renamable $x18
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Machine Loop Invariant Code Motion (machinelicm) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12
  renamable $x18 = COPY $x11
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  renamable $x19 = COPY $x12
  BLT $x0, killed renamable $x13, %bb.1

bb.11:
; predecessors: %bb.0
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x18, $x19
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BEQ killed renamable $x10, $x0, %bb.5

bb.12:
; predecessors: %bb.4
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = COPY killed renamable $x8
  PseudoBR %bb.10

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2

bb.13:
; predecessors: %bb.6
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.10.cleanup:
; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13
  liveins: $x18
  $x10 = COPY killed renamable $x18
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After RISCV Redundant Copy Elimination (riscv-copyelim) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12
  renamable $x18 = COPY $x11
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  renamable $x19 = COPY $x12
  BLT $x0, killed renamable $x13, %bb.1

bb.11:
; predecessors: %bb.0
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x18, $x19
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BEQ killed renamable $x10, $x0, %bb.5

bb.12:
; predecessors: %bb.4
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = COPY killed renamable $x8
  PseudoBR %bb.10

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2

bb.13:
; predecessors: %bb.6
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.10.cleanup:
; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13
  liveins: $x18
  $x10 = COPY killed renamable $x18
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Remove Redundant DEBUG_VALUE analysis (removeredundantdebugvalues) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12
  renamable $x18 = COPY $x11
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  renamable $x19 = COPY $x12
  BLT $x0, killed renamable $x13, %bb.1

bb.11:
; predecessors: %bb.0
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x18, $x19
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BEQ killed renamable $x10, $x0, %bb.5

bb.12:
; predecessors: %bb.4
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = COPY killed renamable $x8
  PseudoBR %bb.10

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2

bb.13:
; predecessors: %bb.6
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.10.cleanup:
; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13
  liveins: $x18
  $x10 = COPY killed renamable $x18
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Fixup Statepoint Caller Saved (fixup-statepoint-caller-saved) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12
  renamable $x18 = COPY $x11
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  renamable $x19 = COPY $x12
  BLT $x0, killed renamable $x13, %bb.1

bb.11:
; predecessors: %bb.0
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x18, $x19
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BEQ killed renamable $x10, $x0, %bb.5

bb.12:
; predecessors: %bb.4
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = COPY killed renamable $x8
  PseudoBR %bb.10

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2

bb.13:
; predecessors: %bb.6
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.10.cleanup:
; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13
  liveins: $x18
  $x10 = COPY killed renamable $x18
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After PostRA Machine Sink (postra-machine-sink) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12
  renamable $x18 = COPY $x11
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BLT $x0, killed renamable $x13, %bb.1

bb.11:
; predecessors: %bb.0
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  renamable $x19 = COPY $x12
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BEQ killed renamable $x10, $x0, %bb.5

bb.12:
; predecessors: %bb.4
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = COPY killed renamable $x8
  PseudoBR %bb.10

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2

bb.13:
; predecessors: %bb.6
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.10.cleanup:
; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13
  liveins: $x18
  $x10 = COPY killed renamable $x18
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Shrink Wrapping analysis (shrink-wrap) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12
  renamable $x18 = COPY $x11
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BLT $x0, killed renamable $x13, %bb.1

bb.11:
; predecessors: %bb.0
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  renamable $x19 = COPY $x12
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BEQ killed renamable $x10, $x0, %bb.5

bb.12:
; predecessors: %bb.4
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = COPY killed renamable $x8
  PseudoBR %bb.10

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  ADJCALLSTACKDOWN 0, 0, implicit-def dead $x2, implicit $x2
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  ADJCALLSTACKUP 0, 0, implicit-def dead $x2, implicit $x2
  BNE killed renamable $x10, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2

bb.13:
; predecessors: %bb.6
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.10.cleanup:
; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13
  liveins: $x18
  $x10 = COPY killed renamable $x18
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Prologue/Epilogue Insertion & Frame Finalization (prologepilog) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  renamable $x18 = COPY $x11
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BLT $x0, killed renamable $x13, %bb.1

bb.11:
; predecessors: %bb.0
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  renamable $x19 = COPY $x12
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.9(0x04000000); %bb.3(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9
  PseudoBR %bb.3

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8
  PseudoBR %bb.4

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.12(0x04000000); %bb.5(96.88%), %bb.12(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BEQ killed renamable $x10, $x0, %bb.5

bb.12:
; predecessors: %bb.4
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = COPY killed renamable $x8
  PseudoBR %bb.10

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.7(0x04000000); %bb.6(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.7
  PseudoBR %bb.6

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.13(0x04000000); %bb.2(96.88%), %bb.13(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2

bb.13:
; predecessors: %bb.6
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x18
  PseudoBR %bb.10

bb.7.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.10

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.10

bb.9.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.10(0x80000000); %bb.10(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.10.cleanup:
; predecessors: %bb.9, %bb.8, %bb.7, %bb.11, %bb.12, %bb.13
  liveins: $x18
  $x10 = COPY killed renamable $x18
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Control Flow Optimizer (branch-folder) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  renamable $x18 = COPY $x11
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  renamable $x19 = COPY $x12
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.7
  successors: %bb.3(0x7c000000), %bb.10(0x04000000); %bb.3(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.9(0x04000000); %bb.4(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.6(0x7c000000), %bb.5(0x04000000); %bb.6(96.88%), %bb.5(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BEQ killed renamable $x10, $x0, %bb.6

bb.5:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = COPY killed renamable $x8
  PseudoBR %bb.11

bb.6.if.end9:
; predecessors: %bb.4
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.7.if.end14:
; predecessors: %bb.6
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.6
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.11

bb.9.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.10.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.11.cleanup:
; predecessors: %bb.10, %bb.9, %bb.8, %bb.5, %bb.0, %bb.7
  liveins: $x18
  $x10 = COPY killed renamable $x18
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Tail Duplication (tailduplication) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  renamable $x18 = COPY $x11
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  renamable $x19 = COPY $x12
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.7
  successors: %bb.3(0x7c000000), %bb.10(0x04000000); %bb.3(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.9(0x04000000); %bb.4(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.6(0x7c000000), %bb.5(0x04000000); %bb.6(96.88%), %bb.5(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BEQ killed renamable $x10, $x0, %bb.6

bb.5:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = COPY killed renamable $x8
  PseudoBR %bb.11

bb.6.if.end9:
; predecessors: %bb.4
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.7.if.end14:
; predecessors: %bb.6
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.6
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.11

bb.9.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.10.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.11.cleanup:
; predecessors: %bb.10, %bb.9, %bb.8, %bb.5, %bb.0, %bb.7
  liveins: $x18
  $x10 = COPY killed renamable $x18
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Machine Copy Propagation Pass (machine-cp) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  renamable $x18 = COPY $x11
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  renamable $x19 = COPY $x12
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.7
  successors: %bb.3(0x7c000000), %bb.10(0x04000000); %bb.3(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.9(0x04000000); %bb.4(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.6(0x7c000000), %bb.5(0x04000000); %bb.6(96.88%), %bb.5(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BEQ killed renamable $x10, $x0, %bb.6

bb.5:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = COPY killed renamable $x8
  PseudoBR %bb.11

bb.6.if.end9:
; predecessors: %bb.4
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.7.if.end14:
; predecessors: %bb.6
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.6
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.11

bb.9.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.10.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.11.cleanup:
; predecessors: %bb.10, %bb.9, %bb.8, %bb.5, %bb.0, %bb.7
  liveins: $x18
  $x10 = COPY killed renamable $x18
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Post-RA pseudo instruction expansion pass (postrapseudos) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.7
  successors: %bb.3(0x7c000000), %bb.10(0x04000000); %bb.3(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.9(0x04000000); %bb.4(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.6(0x7c000000), %bb.5(0x04000000); %bb.6(96.88%), %bb.5(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BEQ killed renamable $x10, $x0, %bb.6

bb.5:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.6.if.end9:
; predecessors: %bb.4
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.7.if.end14:
; predecessors: %bb.6
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.6
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.11

bb.9.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.10.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.11.cleanup:
; predecessors: %bb.10, %bb.9, %bb.8, %bb.5, %bb.0, %bb.7
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Post RA top-down list latency scheduler (post-RA-sched) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.7
  successors: %bb.3(0x7c000000), %bb.10(0x04000000); %bb.3(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.9(0x04000000); %bb.4(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.6(0x7c000000), %bb.5(0x04000000); %bb.6(96.88%), %bb.5(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BEQ killed renamable $x10, $x0, %bb.6

bb.5:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.6.if.end9:
; predecessors: %bb.4
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.7.if.end14:
; predecessors: %bb.6
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.6
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.11

bb.9.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.10.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.11.cleanup:
; predecessors: %bb.10, %bb.9, %bb.8, %bb.5, %bb.0, %bb.7
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Analyze Machine Code For Garbage Collection (gc-analysis) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.7
  successors: %bb.3(0x7c000000), %bb.10(0x04000000); %bb.3(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.9(0x04000000); %bb.4(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.6(0x7c000000), %bb.5(0x04000000); %bb.6(96.88%), %bb.5(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BEQ killed renamable $x10, $x0, %bb.6

bb.5:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.6.if.end9:
; predecessors: %bb.4
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.7.if.end14:
; predecessors: %bb.6
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.6
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4
  PseudoBR %bb.11

bb.9.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.10.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8

bb.11.cleanup:
; predecessors: %bb.10, %bb.9, %bb.8, %bb.5, %bb.0, %bb.7
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Branch Probability Basic Block Placement (block-placement) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.7
  successors: %bb.3(0x7c000000), %bb.10(0x04000000); %bb.3(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.9(0x04000000); %bb.4(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.6(0x7c000000), %bb.5(0x04000000); %bb.6(96.88%), %bb.5(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.5

bb.6.if.end9:
; predecessors: %bb.4
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.7.if.end14:
; predecessors: %bb.6
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.10.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.9.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.5:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.6
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.10, %bb.9, %bb.8, %bb.5, %bb.0, %bb.7
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Insert fentry calls (fentry-insert) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.7
  successors: %bb.3(0x7c000000), %bb.10(0x04000000); %bb.3(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.9(0x04000000); %bb.4(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.6(0x7c000000), %bb.5(0x04000000); %bb.6(96.88%), %bb.5(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.5

bb.6.if.end9:
; predecessors: %bb.4
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.7.if.end14:
; predecessors: %bb.6
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.10.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.9.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.5:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.6
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.10, %bb.9, %bb.8, %bb.5, %bb.0, %bb.7
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Insert XRay ops (xray-instrumentation) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.7
  successors: %bb.3(0x7c000000), %bb.10(0x04000000); %bb.3(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.9(0x04000000); %bb.4(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.6(0x7c000000), %bb.5(0x04000000); %bb.6(96.88%), %bb.5(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.5

bb.6.if.end9:
; predecessors: %bb.4
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.7.if.end14:
; predecessors: %bb.6
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.10.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.9.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.5:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.6
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.10, %bb.9, %bb.8, %bb.5, %bb.0, %bb.7
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Implement the 'patchable-function' attribute (patchable-function) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.7
  successors: %bb.3(0x7c000000), %bb.10(0x04000000); %bb.3(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.9(0x04000000); %bb.4(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.6(0x7c000000), %bb.5(0x04000000); %bb.6(96.88%), %bb.5(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.5

bb.6.if.end9:
; predecessors: %bb.4
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.7.if.end14:
; predecessors: %bb.6
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.10.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.9.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.5:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.6
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.10, %bb.9, %bb.8, %bb.5, %bb.0, %bb.7
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After RISCV add/sub combiner pass (riscv-addsub-comb) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.7
  successors: %bb.3(0x7c000000), %bb.10(0x04000000); %bb.3(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.9(0x04000000); %bb.4(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.6(0x7c000000), %bb.5(0x04000000); %bb.6(96.88%), %bb.5(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.5

bb.6.if.end9:
; predecessors: %bb.4
  successors: %bb.7(0x7c000000), %bb.8(0x04000000); %bb.7(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.7.if.end14:
; predecessors: %bb.6
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.10.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.9.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.5:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.6
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.10, %bb.9, %bb.8, %bb.5, %bb.0, %bb.7
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Branch relaxation pass (branch-relaxation) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.7(0x04000000); %bb.3(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.7

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.9(0x04000000); %bb.5(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.10(0x04000000); %bb.6(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.7.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.9:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.10.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.7, %bb.8, %bb.10, %bb.9, %bb.0, %bb.6
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After RISCV Make Compressible (riscv-make-compressible) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.7(0x04000000); %bb.3(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.7

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.9(0x04000000); %bb.5(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.10(0x04000000); %bb.6(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.7.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.9:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.10.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.7, %bb.8, %bb.10, %bb.9, %bb.0, %bb.6
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Contiguously Lay Out Funclets (funclet-layout) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.7(0x04000000); %bb.3(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.7

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.9(0x04000000); %bb.5(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.10(0x04000000); %bb.6(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.7.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.9:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.10.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.7, %bb.8, %bb.10, %bb.9, %bb.0, %bb.6
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After StackMap Liveness Analysis (stackmap-liveness) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.7(0x04000000); %bb.3(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.7

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.9(0x04000000); %bb.5(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.10(0x04000000); %bb.6(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.7.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.9:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.10.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.7, %bb.8, %bb.10, %bb.9, %bb.0, %bb.6
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After Live DEBUG_VALUE analysis (livedebugvalues) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.7(0x04000000); %bb.3(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.7

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.9(0x04000000); %bb.5(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.10(0x04000000); %bb.6(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.7.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.9:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.10.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.7, %bb.8, %bb.10, %bb.9, %bb.0, %bb.6
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

*** IR Dump After Machine Outliner (machine-outliner) ***
; ModuleID = 'find_if.cpp'
source_filename = "find_if.cpp"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "riscv64-unknown-linux-gnu"

; Function Attrs: mustprogress
define dso_local noundef ptr @_Z3fooPiS_PFiiE(ptr noundef %__first, ptr noundef %__last, ptr nocapture noundef readonly %__pred) local_unnamed_addr #0 {
entry:
  %sub.ptr.lhs.cast = ptrtoint ptr %__last to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %__first to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %0 = lshr i64 %sub.ptr.sub, 4
  %conv = trunc i64 %0 to i32
  %cmp43 = icmp sgt i32 %conv, 0
  br i1 %cmp43, label %for.body.preheader, label %cleanup

for.body.preheader:                               ; preds = %entry
  %1 = trunc i64 %0 to i32
  %2 = add i32 %1, 1
  %uglygep = getelementptr i8, ptr %__first, i64 8
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %if.end14
  %lsr.iv68 = phi ptr [ %uglygep, %for.body.preheader ], [ %uglygep69, %if.end14 ]
  %lsr.iv = phi i32 [ %2, %for.body.preheader ], [ %lsr.iv.next, %if.end14 ]
  %uglygep74 = getelementptr i8, ptr %lsr.iv68, i64 -8
  %3 = load i32, ptr %uglygep74, align 4, !tbaa !6
  %call = tail call noundef signext i32 %__pred(i32 noundef signext %3)
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %for.body.cleanup.loopexit_crit_edge

if.end:                                           ; preds = %for.body
  %uglygep75 = getelementptr i8, ptr %lsr.iv68, i64 -4
  %4 = load i32, ptr %uglygep75, align 4, !tbaa !6
  %call1 = tail call noundef signext i32 %__pred(i32 noundef signext %4)
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end4, label %cleanup.loopexit.split.loop.exit51

if.end4:                                          ; preds = %if.end
  %5 = load i32, ptr %lsr.iv68, align 4, !tbaa !6
  %call6 = tail call noundef signext i32 %__pred(i32 noundef signext %5)
  %tobool7.not = icmp eq i32 %call6, 0
  br i1 %tobool7.not, label %if.end9, label %cleanup

if.end9:                                          ; preds = %if.end4
  %uglygep73 = getelementptr i8, ptr %lsr.iv68, i64 4
  %6 = load i32, ptr %uglygep73, align 4, !tbaa !6
  %call11 = tail call noundef signext i32 %__pred(i32 noundef signext %6)
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %cleanup.loopexit.split.loop.exit

if.end14:                                         ; preds = %if.end9
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep69 = getelementptr i8, ptr %lsr.iv68, i64 16
  %cmp = icmp sgt i32 %lsr.iv.next, 1
  br i1 %cmp, label %for.body, label %cleanup, !llvm.loop !10

cleanup.loopexit.split.loop.exit:                 ; preds = %if.end9
  %uglygep72 = getelementptr i8, ptr %lsr.iv68, i64 4
  br label %cleanup

cleanup.loopexit.split.loop.exit51:               ; preds = %if.end
  %uglygep71 = getelementptr i8, ptr %lsr.iv68, i64 -4
  br label %cleanup

for.body.cleanup.loopexit_crit_edge:              ; preds = %for.body
  %uglygep70 = getelementptr i8, ptr %lsr.iv68, i64 -8
  br label %cleanup

cleanup:                                          ; preds = %for.body.cleanup.loopexit_crit_edge, %if.end14, %if.end4, %cleanup.loopexit.split.loop.exit, %cleanup.loopexit.split.loop.exit51, %entry
  %retval.0 = phi ptr [ %__last, %entry ], [ %uglygep72, %cleanup.loopexit.split.loop.exit ], [ %uglygep71, %cleanup.loopexit.split.loop.exit51 ], [ %lsr.iv68, %if.end4 ], [ %uglygep70, %for.body.cleanup.loopexit_crit_edge ], [ %__last, %if.end14 ]
  ret ptr %retval.0
}

attributes #0 = { mustprogress "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+64bit,+a,+c,+d,+f,+m,+relax,+zicsr,+zifencei,-save-restore" "tune-cpu"="scr7" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"lp64d"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 1, !"SmallDataLimit", i32 8}
!5 = !{!"clang version 16.0.0 (SC git:/tools/llvm/llvm-project/ 3c24c22cfb18fe238c75d94115507e94ba94a155)"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !8, i64 0}
!8 = !{!"omnipotent char", !9, i64 0}
!9 = !{!"Simple C++ TBAA"}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.mustprogress"}
# *** IR Dump After RISCV pseudo instruction expansion pass (riscv-expand-pseudo) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.7(0x04000000); %bb.3(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.7

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.9(0x04000000); %bb.5(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.10(0x04000000); %bb.6(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.7.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.9:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.10.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.7, %bb.8, %bb.10, %bb.9, %bb.0, %bb.6
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

# *** IR Dump After RISCV atomic pseudo instruction expansion pass (riscv-expand-atomic-pseudo) ***:
# Machine code for function _Z3fooPiS_PFiiE: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=8, align=8, at location [SP-8]
  fi#1: size=8, align=8, at location [SP-16]
  fi#2: size=8, align=8, at location [SP-24]
  fi#3: size=8, align=8, at location [SP-32]
  fi#4: size=8, align=8, at location [SP-40]
  fi#5: size=8, align=8, at location [SP-48]
Function Live Ins: $x10, $x11, $x12

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.11(0x30000000); %bb.1(62.50%), %bb.11(37.50%)
  liveins: $x10, $x11, $x12, $x1, $x8, $x9, $x18, $x19, $x20
  $x2 = frame-setup ADDI $x2, -48
  frame-setup CFI_INSTRUCTION def_cfa_offset 48
  SD killed $x1, $x2, 40 :: (store (s64) into %stack.0)
  SD killed $x8, $x2, 32 :: (store (s64) into %stack.1)
  SD killed $x9, $x2, 24 :: (store (s64) into %stack.2)
  SD killed $x18, $x2, 16 :: (store (s64) into %stack.3)
  SD killed $x19, $x2, 8 :: (store (s64) into %stack.4)
  SD killed $x20, $x2, 0 :: (store (s64) into %stack.5)
  frame-setup CFI_INSTRUCTION offset $x1, -8
  frame-setup CFI_INSTRUCTION offset $x8, -16
  frame-setup CFI_INSTRUCTION offset $x9, -24
  frame-setup CFI_INSTRUCTION offset $x18, -32
  frame-setup CFI_INSTRUCTION offset $x19, -40
  frame-setup CFI_INSTRUCTION offset $x20, -48
  $x18 = ADDI $x11, 0
  renamable $x11 = SUB killed $x11, renamable $x10
  renamable $x11 = SRLI killed renamable $x11, 4
  renamable $x13 = ADDIW renamable $x11, 0
  BGE $x0, killed renamable $x13, %bb.11

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $x10, $x11, $x12, $x18
  $x19 = ADDI killed $x12, 0
  renamable $x9 = ADDIW killed renamable $x11, 1
  renamable $x8 = ADDI killed renamable $x10, 8
  renamable $x20 = ADDI $x0, 1

bb.2.for.body:
; predecessors: %bb.1, %bb.6
  successors: %bb.3(0x7c000000), %bb.7(0x04000000); %bb.3(96.88%), %bb.7(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -8 :: (load (s32) from %ir.uglygep74, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.7

bb.3.if.end:
; predecessors: %bb.2
  successors: %bb.4(0x7c000000), %bb.8(0x04000000); %bb.4(96.88%), %bb.8(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, -4 :: (load (s32) from %ir.uglygep75, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.8

bb.4.if.end4:
; predecessors: %bb.3
  successors: %bb.5(0x7c000000), %bb.9(0x04000000); %bb.5(96.88%), %bb.9(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 0 :: (load (s32) from %ir.lsr.iv68, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.9

bb.5.if.end9:
; predecessors: %bb.4
  successors: %bb.6(0x7c000000), %bb.10(0x04000000); %bb.6(96.88%), %bb.10(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x10 = LW renamable $x8, 4 :: (load (s32) from %ir.uglygep73, !tbaa !6)
  PseudoCALLIndirect renamable $x19, <regmask $vlenb $x0 $x1 $x3 $x4 $x8 $x9 $x18 $x19 $x20 $x21 $x22 $x23 $x24 $x25 $x26 $x27 $f8_d $f9_d $f18_d $f19_d $f20_d $f21_d $f22_d $f23_d $f24_d $f25_d $f26_d $f27_d $f8_f $f9_f $f18_f $f19_f and 20 more...>, implicit-def dead $x1, implicit killed $x10, implicit-def $x2, implicit-def $x10
  BNE killed renamable $x10, $x0, %bb.10

bb.6.if.end14:
; predecessors: %bb.5
  successors: %bb.2(0x7c000000), %bb.11(0x04000000); %bb.2(96.88%), %bb.11(3.12%)
  liveins: $x8, $x9, $x18, $x19, $x20
  renamable $x9 = ADDIW killed renamable $x9, -1
  renamable $x8 = ADDI killed renamable $x8, 16
  BLT renamable $x20, renamable $x9, %bb.2
  PseudoBR %bb.11

bb.7.for.body.cleanup.loopexit_crit_edge:
; predecessors: %bb.2
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -8
  PseudoBR %bb.11

bb.8.cleanup.loopexit.split.loop.exit51:
; predecessors: %bb.3
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, -4
  PseudoBR %bb.11

bb.9:
; predecessors: %bb.4
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  $x18 = ADDI killed $x8, 0
  PseudoBR %bb.11

bb.10.cleanup.loopexit.split.loop.exit:
; predecessors: %bb.5
  successors: %bb.11(0x80000000); %bb.11(100.00%)
  liveins: $x8
  renamable $x18 = ADDI killed renamable $x8, 4

bb.11.cleanup:
; predecessors: %bb.7, %bb.8, %bb.10, %bb.9, %bb.0, %bb.6
  liveins: $x18
  $x10 = ADDI killed $x18, 0
  $x1 = LD $x2, 40 :: (load (s64) from %stack.0)
  $x8 = LD $x2, 32 :: (load (s64) from %stack.1)
  $x9 = LD $x2, 24 :: (load (s64) from %stack.2)
  $x18 = LD $x2, 16 :: (load (s64) from %stack.3)
  $x19 = LD $x2, 8 :: (load (s64) from %stack.4)
  $x20 = LD $x2, 0 :: (load (s64) from %stack.5)
  $x2 = frame-destroy ADDI $x2, 48
  PseudoRET implicit killed $x10

# End machine code for function _Z3fooPiS_PFiiE.

